#include "jsh.h"
#include <Util.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <sys/select.h>
#include <algorithm>
#include <functional>
#include <mutex>

static JSH* sJSH = 0;
static int sJshPipe[2];
static UVMutex sMutex;

void signal(int s)
{
    int e;
    unsigned char c = static_cast<unsigned char>(s);
    eintrwrap(e, ::write(sJshPipe[1], &c, 1));
}

using namespace v8;
using namespace node;

Persistent<FunctionTemplate> JSH::constructor;

static Handle<Value> GetInteractive(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::Boolean::New(obj->interactive());
}

static Handle<Value> GetPgid(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::Integer::New(obj->pgid());
}

static Handle<Value> GetTermios(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    Handle<External> ext = External::New(obj->term());
    Handle<Object> ret = obj->templ()->NewInstance();
    ret->SetInternalField(0, ext);
    return ret;
}

void JSH::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("jsh");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    // set up properties
    constructor->InstanceTemplate()->SetAccessor(String::New("interactive"), GetInteractive);
    constructor->InstanceTemplate()->SetAccessor(String::New("pgid"), GetPgid);
    constructor->InstanceTemplate()->SetAccessor(String::New("termios"), GetTermios);

    NODE_SET_PROTOTYPE_METHOD(constructor, "cleanup", cleanup);
    NODE_SET_PROTOTYPE_METHOD(constructor, "isExecutable", isExecutable);

    target->Set(name, constructor->GetFunction());
}

Handle<Value> JSH::cleanup(const Arguments& args)
{
    HandleScope scope;

    JSH* obj = ObjectWrap::Unwrap<JSH>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("JSH.cleanup takes no arguments")));
    }
    obj->cleanup();

    return Undefined();
}

Handle<Value> JSH::isExecutable(const Arguments& args)
{
    HandleScope scope;

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("JSH.isExecutable takes a path argument")));
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        return ThrowException(Exception::TypeError(String::New("JSH.isExecutable takes a path argument")));
    }

    Handle<String> arg = Handle<String>::Cast(args[0]);
    String::Utf8Value path(arg);
    struct stat st;
    if (::stat(*path, &st) != 0) {
        return False();
    }
    return ((st.st_mode & (S_IFREG|S_IXUSR)) == (S_IFREG|S_IXUSR)) ? True() : False();
}

void JSH::cleanup()
{
    tcsetattr(STDIN_FILENO, 0, &shellTmodes);
}

JSH::JSH()
    : ObjectWrap()
{
    assert(!sJSH);
    sJSH = this;

    if (::pipe(sJshPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }

    interact = isatty(STDIN_FILENO);
    if (interact) {
        while (tcgetpgrp(STDIN_FILENO) != (shellPgid = getpgrp()))
            kill(-shellPgid, SIGTTIN);

        ::signal(SIGINT, SIG_IGN);
        ::signal(SIGQUIT, SIG_IGN);
        ::signal(SIGTSTP, SIG_IGN);
        ::signal(SIGTTIN, SIG_IGN);
        ::signal(SIGTTOU, SIG_IGN);

        shellPgid = getpid();
        if (setpgid(shellPgid, shellPgid) < 0) {
            fprintf(stderr, "Couldn't put the shell in its own process group");
            abort();
        }

        tcsetpgrp(STDIN_FILENO, shellPgid);
        tcgetattr(STDIN_FILENO, &shellTmodes);
    }
}

JSH::~JSH()
{
    assert(sJSH == this);
    ::close(sJshPipe[0]);
    ::close(sJshPipe[1]);
    sJSH = 0;
}

Handle<Value> JSH::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 0) {
        return ThrowException(Exception::TypeError(String::New("JSH takes no arguments")));
    }

    if (sJSH) {
        return ThrowException(Exception::TypeError(String::New("Can only have one JSH object at a time")));
    }

    JSH* obj = new JSH;

    Handle<ObjectTemplate> templ = ObjectTemplate::New();
    templ->SetInternalFieldCount(1);

    obj->termiosTemplate = Persistent<v8::ObjectTemplate>::New(templ);
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    JSH::init(target);
}

NODE_MODULE(jsh, RegisterModule);
