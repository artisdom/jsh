#include "jsh.h"
#include <JSHUtil.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <sys/select.h>
#include <sys/file.h>
#include <algorithm>
#include <functional>
#include <mutex>
#include <vector>
#include <string>

static JSH* sJSH = 0;
static int sJshPipe[2] = { -1, -1 };
static UVMutex sMutex;

void signal(int s)
{
    int e;
    unsigned char c = static_cast<unsigned char>(s);
    eintrwrap(e, ::write(sJshPipe[1], &c, 1));
}

using namespace v8;
using namespace node;

Persistent<FunctionTemplate> JSH::constructor;

static NAN_GETTER(GetInteractive)
{
    NanScope();
    JSH* obj = ObjectWrap::Unwrap<JSH>(args.Holder());
    NanReturnValue(NanNew<Boolean>(obj->interactive()));
}

static NAN_GETTER(GetPgid)
{
    NanScope();
    JSH* obj = ObjectWrap::Unwrap<JSH>(args.Holder());
    NanReturnValue(NanNew<Integer>(obj->pgid()));
}

static NAN_GETTER(GetTermios)
{
    NanScope();
    JSH* obj = ObjectWrap::Unwrap<JSH>(args.Holder());
    Handle<External> ext = External::New(Isolate::GetCurrent(), obj->term());
    Handle<Object> ret = NanNew<ObjectTemplate>(obj->templ())->NewInstance();
    ret->SetInternalField(0, ext);
    NanReturnValue(ret);
}

void JSH::init(Handle<Object> target)
{
    NanScope();

    auto tpl = NanNew<FunctionTemplate>(JSH::New);
    NanAssignPersistent(constructor, tpl);
    const auto name = NanSymbol("jsh");

    tpl->InstanceTemplate()->SetInternalFieldCount(1);
    tpl->SetClassName(name);

    // set up properties
    tpl->InstanceTemplate()->SetAccessor(NanSymbol("interactive"), GetInteractive);
    tpl->InstanceTemplate()->SetAccessor(NanSymbol("pgid"), GetPgid);
    tpl->InstanceTemplate()->SetAccessor(NanSymbol("termios"), GetTermios);

    NODE_SET_PROTOTYPE_METHOD(tpl, "cleanup", cleanup);
    NODE_SET_PROTOTYPE_METHOD(tpl, "setupShell", setupShell);
    NODE_SET_PROTOTYPE_METHOD(tpl, "isExecutable", isExecutable);
    NODE_SET_PROTOTYPE_METHOD(tpl, "execSync", execSync);
    NODE_SET_PROTOTYPE_METHOD(tpl, "flockSync", flockSync);
    NODE_SET_PROTOTYPE_METHOD(tpl, "stdout", writeStdout);
    NODE_SET_PROTOTYPE_METHOD(tpl, "stderr", writeStderr);

    target->Set(name, tpl->GetFunction());
}

#define WRITE_FILE(f)                           \
    for (int i = 0; i < args.Length(); ++i) {   \
        String::Utf8Value val(args[i]);         \
        fprintf(f, "%s", *val);                 \
    }

NAN_METHOD(JSH::writeStdout)
{
    NanScope();
    WRITE_FILE(stdout);
    NanReturnUndefined();
}

NAN_METHOD(JSH::writeStderr)
{
    NanScope();
    WRITE_FILE(stderr);
    NanReturnUndefined();
}

NAN_METHOD(JSH::cleanup)
{
    NanScope();

    JSH* obj = ObjectWrap::Unwrap<JSH>(args.This());
    if (args.Length() > 0) {
        return NanThrowError("JSH.cleanup takes no arguments");
    }
    obj->cleanup();

    NanReturnUndefined();
}

NAN_METHOD(JSH::isExecutable)
{
    NanScope();

    if (args.Length() != 1) {
        return NanThrowError("JSH.isExecutable takes a path argument");
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        return NanThrowError("JSH.isExecutable takes a path argument");
    }

    Handle<String> arg = Handle<String>::Cast(args[0]);
    String::Utf8Value path(arg);
    struct stat st;
    if (::stat(*path, &st) != 0) {
        NanReturnValue(NanFalse());
    }
    NanReturnValue(((st.st_mode & (S_IFREG|S_IXUSR)) == (S_IFREG|S_IXUSR)) ? NanTrue() : NanFalse());
}

NAN_METHOD(JSH::execSync)
{
    NanScope();

    if (args.Length() != 2) {
        return NanThrowError("JSH.execSync takes a path and an array argument");
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        return NanThrowError("JSH.execSync takes a path argument");
    }
    if (args[1].IsEmpty() || !args[1]->IsArray()) {
        return NanThrowError("JSH.execSync takes an array argument");
    }

    int stdoutPipe[2], stderrPipe[2];
    if (::pipe(stdoutPipe)) {
        return NanThrowError("JSH.execSync pipe failed");
    }
    if (::pipe(stderrPipe)) {
        return NanThrowError("JSH.execSync pipe failed");
    }

    pid_t pid = ::fork();
    switch (pid) {
    case -1:
        // something horrible has happened
        return NanThrowError("JSH.execSync fork failed");
    case 0: {
        // child, build the argument array
        Handle<Array> arr = Handle<Array>::Cast(args[1]);
        String::Utf8Value prog(args[0]);

        std::vector<std::string> args;
        std::vector<const char*> cargs;
        args.push_back(*prog);
        cargs.push_back(args.back().c_str());

        for (size_t i = 0; i < arr->Length(); ++i) {
            String::Utf8Value val(arr->Get(i));
            args.push_back(*val);
            cargs.push_back(args.back().c_str());
        }
        cargs.push_back(0);

        // dup fd's
        ::close(stdoutPipe[0]);
        ::dup2(stdoutPipe[1], STDOUT_FILENO);
        ::close(stdoutPipe[1]);
        ::close(stderrPipe[0]);
        ::dup2(stderrPipe[1], STDERR_FILENO);
        ::close(stderrPipe[1]);

        ::execv(*prog, const_cast<char* const*>(&cargs[0]));
        _exit(1);
        break; }
    }

    assert(pid > 0);

    ::close(stdoutPipe[1]);
    ::close(stderrPipe[1]);

    std::string outData, errData;
    bool outDone = false, errDone = false;

    // select and read from pipe
    fd_set rd;
    int s;
    const int max = std::max(stdoutPipe[0], stderrPipe[0]);
    for (;;) {
        FD_ZERO(&rd);
        FD_SET(stdoutPipe[0], &rd);
        FD_SET(stderrPipe[0], &rd);
        eintrwrap(s, ::select(max + 1, &rd, 0, 0, 0));
        if (s <= 0) {
            // bust!
            return NanThrowError("JSH.execSync select failed");
        }
        if (FD_ISSET(stdoutPipe[0], &rd)) {
            // read
            char buf[8192];
            eintrwrap(s, ::read(stdoutPipe[0], buf, sizeof(buf)));

            if (s < 0) {
                // bust!
                return NanThrowError("JSH.execSync read out failed");
            }
            if (s == 0) {
                // done?
                outDone = true;
                if (errDone)
                    break;
            }
            outData += std::string(buf, s);
        }
        if (FD_ISSET(stderrPipe[0], &rd)) {
            // read
            char buf[8192];
            eintrwrap(s, ::read(stderrPipe[0], buf, sizeof(buf)));

            if (s < 0) {
                // bust!
                return NanThrowError("JSH.execSync read err failed");
            }
            if (s == 0) {
                // done?
                errDone = true;
                if (outDone)
                    break;
            }
            errData += std::string(buf, s);
        }
    }

    ::close(stdoutPipe[0]);
    ::close(stderrPipe[0]);

    Handle<Object> obj = NanNew<Object>();
    if (!outData.empty())
        obj->Set(NanSymbol("stdout"), NanNew<String>(outData.c_str(), outData.size()));
    if (!errData.empty())
        obj->Set(NanSymbol("stderr"), NanNew<String>(errData.c_str(), errData.size()));

    NanReturnValue(obj);
}


NAN_METHOD(JSH::flockSync)
{
    NanScope();

    if (args.Length() != 2) {
        return NanThrowError("JSH.flockSync takes a file descriptor and a mode argument");
    }
    if (args[0].IsEmpty() || !args[0]->IsInt32()) {
        return NanThrowError("JSH.flockSync takes a file descriptor argument");
    }
    if (args[1].IsEmpty() || !args[1]->IsArray()) {
        return NanThrowError("JSH.flockSync takes a an array of strings argument");
    }

    unsigned int operation = 0;
    const Handle<Array> modes = Handle<Array>::Cast(args[1]);
    for (size_t i=0; i<modes->Length(); ++i) {
        if (!modes->Get(i)->IsString()) {
            return NanThrowError("JSH.flockSync takes a an array of strings argument");
        }
        const String::Utf8Value mode(modes->Get(i));
        if (!strcasecmp(*mode, "shared")) {
            operation |= LOCK_SH;
        } else if (!strcasecmp(*mode, "exclusive")) {
            operation |= LOCK_EX;
        } else if (!strcasecmp(*mode, "unlock")) {
            operation |= LOCK_UN;
        } else if (!strcasecmp(*mode, "nonblocking")) {
            operation |= LOCK_NB;
        } else {
            return NanThrowError("JSH.flockSync unrecognized mode, available modes are: 'shared', 'exclusive', 'unlock' and 'nonblocking'");

        }
    }

    if (::flock(args[0]->ToInt32()->Value(), operation) != 0) {
        char buf[1024];
        const int w = snprintf(buf, sizeof(buf), "flock error '%s' (%d)", strerror(errno), errno);
        return NanThrowError(buf, w);
    }
    NanReturnValue(NanTrue());
}

void JSH::cleanup()
{
    tcsetattr(STDIN_FILENO, 0, &shellTmodes);
}

JSH::JSH()
    : ObjectWrap()
{
    assert(!sJSH);
    sJSH = this;
}

NAN_METHOD(JSH::setupShell)
{
    NanScope();
    JSH* obj = ObjectWrap::Unwrap<JSH>(args.This());

    assert((sJshPipe[0] == sJshPipe[1]) && (sJshPipe[0] == -1));

    if (::pipe(sJshPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }

    obj->interact = isatty(STDIN_FILENO);
    if (obj->interact) {
        while (tcgetpgrp(STDIN_FILENO) != (obj->shellPgid = getpgrp()))
            kill(-obj->shellPgid, SIGTTIN);

        ::signal(SIGINT, SIG_IGN);
        ::signal(SIGQUIT, SIG_IGN);
        ::signal(SIGTSTP, SIG_IGN);
        ::signal(SIGTTIN, SIG_IGN);
        ::signal(SIGTTOU, SIG_IGN);

        obj->shellPgid = getpid();
        if (setpgid(obj->shellPgid, obj->shellPgid) < 0) {
            fprintf(stderr, "Couldn't put the shell in its own process group");
            abort();
        }

        tcsetpgrp(STDIN_FILENO, obj->shellPgid);
        tcgetattr(STDIN_FILENO, &obj->shellTmodes);
    }
    NanReturnUndefined();
}

JSH::~JSH()
{
    assert(sJSH == this);
    ::close(sJshPipe[0]);
    ::close(sJshPipe[1]);
    sJSH = 0;
}

NAN_METHOD(JSH::New)
{
    NanScope();

    if (!args.IsConstructCall()) {
        return NanThrowError("Use the new operator to create instances of this object.");
    }

    if (args.Length() != 0) {
        return NanThrowError("JSH takes no arguments");
    }

    if (sJSH) {
        return NanThrowError("Can only have one JSH object at a time");
    }

    JSH* obj = new JSH;

    Handle<ObjectTemplate> templ = ObjectTemplate::New();
    templ->SetInternalFieldCount(1);

    NanAssignPersistent(obj->termiosTemplate, templ);
    obj->Wrap(args.This());

    NanReturnValue(args.This());
}

void RegisterModule(Handle<Object> target)
{
    JSH::init(target);
}

NODE_MODULE(jsh, RegisterModule);
