#include "jsh.h"
#include <Util.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <sys/select.h>
#include <algorithm>
#include <functional>
#include <mutex>

static JSH* sJSH = 0;
static int sJshPipe[2];
static UVMutex sMutex;

void signal(int s)
{
    int e;
    unsigned char c = static_cast<unsigned char>(s);
    eintrwrap(e, ::write(sJshPipe[1], &c, 1));
}

using namespace v8;
using namespace node;

Persistent<FunctionTemplate> JSH::constructor;

static Handle<Value> GetInteractive(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::Boolean::New(obj->interactive());
}

static Handle<Value> GetPgid(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::Integer::New(obj->pgid());
}

static Handle<Value> GetTermios(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    Handle<External> ext = External::New(obj->term());
    Handle<Object> ret = obj->templ()->NewInstance();
    ret->SetInternalField(0, ext);
    return ret;
}

void JSH::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("jsh");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    // set up properties
    constructor->InstanceTemplate()->SetAccessor(String::New("interactive"), GetInteractive);
    constructor->InstanceTemplate()->SetAccessor(String::New("pgid"), GetPgid);
    constructor->InstanceTemplate()->SetAccessor(String::New("termios"), GetTermios);

    NODE_SET_PROTOTYPE_METHOD(constructor, "cleanup", cleanup);
    NODE_SET_PROTOTYPE_METHOD(constructor, "isExecutable", isExecutable);
    NODE_SET_PROTOTYPE_METHOD(constructor, "execSync", execSync);

    target->Set(name, constructor->GetFunction());
}

Handle<Value> JSH::cleanup(const Arguments& args)
{
    HandleScope scope;

    JSH* obj = ObjectWrap::Unwrap<JSH>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("JSH.cleanup takes no arguments")));
    }
    obj->cleanup();

    return Undefined();
}

Handle<Value> JSH::isExecutable(const Arguments& args)
{
    HandleScope scope;

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("JSH.isExecutable takes a path argument")));
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        return ThrowException(Exception::TypeError(String::New("JSH.isExecutable takes a path argument")));
    }

    Handle<String> arg = Handle<String>::Cast(args[0]);
    String::Utf8Value path(arg);
    struct stat st;
    if (::stat(*path, &st) != 0) {
        return False();
    }
    return ((st.st_mode & (S_IFREG|S_IXUSR)) == (S_IFREG|S_IXUSR)) ? True() : False();
}

Handle<Value> JSH::execSync(const Arguments& args)
{
    HandleScope scope;

    if (args.Length() != 2) {
        return ThrowException(Exception::TypeError(String::New("JSH.execSync takes a path and an array argument")));
    }
    if (args[0].IsEmpty() || !args[0]->IsString()) {
        return ThrowException(Exception::TypeError(String::New("JSH.execSync takes a path argument")));
    }
    if (args[1].IsEmpty() || !args[1]->IsArray()) {
        return ThrowException(Exception::TypeError(String::New("JSH.execSync takes an arary argument")));
    }

    int stdoutPipe[2], stderrPipe[2];
    if (::pipe(stdoutPipe)) {
        return ThrowException(Exception::TypeError(String::New("JSH.execSync pipe failed")));
    }
    if (::pipe(stderrPipe)) {
        return ThrowException(Exception::TypeError(String::New("JSH.execSync pipe failed")));
    }

    pid_t pid = ::fork();
    switch (pid) {
    case -1:
        // something horrible has happened
        return ThrowException(Exception::TypeError(String::New("JSH.execSync fork failed")));
    case 0: {
        // child, build the argument array
        Handle<Array> arr = Handle<Array>::Cast(args[1]);
        String::Utf8Value prog(args[0]);

        std::vector<std::string> args;
        std::vector<const char*> cargs;
        args.push_back(*prog);
        cargs.push_back(args.back().c_str());

        for (size_t i = 0; i < arr->Length(); ++i) {
            String::Utf8Value val(arr->Get(i));
            args.push_back(*val);
            cargs.push_back(args.back().c_str());
        }
        cargs.push_back(0);

        // dup fd's
        ::close(stdoutPipe[0]);
        ::dup2(stdoutPipe[1], STDOUT_FILENO);
        ::close(stdoutPipe[1]);
        ::close(stderrPipe[0]);
        ::dup2(stderrPipe[1], STDERR_FILENO);
        ::close(stderrPipe[1]);

        ::execv(*prog, const_cast<char* const*>(&cargs[0]));
        _exit(1);
        break; }
    }

    assert(pid > 0);

    ::close(stdoutPipe[1]);
    ::close(stderrPipe[1]);

    std::string outData, errData;
    bool outDone = false, errDone = false;

    // select and read from pipe
    fd_set rd;
    int s;
    const int max = std::max(stdoutPipe[0], stderrPipe[0]);
    for (;;) {
        FD_ZERO(&rd);
        FD_SET(stdoutPipe[0], &rd);
        FD_SET(stderrPipe[0], &rd);
        eintrwrap(s, ::select(max + 1, &rd, 0, 0, 0));
        if (s <= 0) {
            // bust!
            return ThrowException(Exception::TypeError(String::New("JSH.execSync select failed")));
        }
        if (FD_ISSET(stdoutPipe[0], &rd)) {
            // read
            char buf[8192];
            eintrwrap(s, ::read(stdoutPipe[0], buf, sizeof(buf)));

            if (s < 0) {
                // bust!
                return ThrowException(Exception::TypeError(String::New("JSH.execSync read out failed")));
            }
            if (s == 0) {
                // done?
                outDone = true;
                if (errDone)
                    break;
            }
            outData += std::string(buf, s);
        }
        if (FD_ISSET(stderrPipe[0], &rd)) {
            // read
            char buf[8192];
            eintrwrap(s, ::read(stderrPipe[0], buf, sizeof(buf)));

            if (s < 0) {
                // bust!
                return ThrowException(Exception::TypeError(String::New("JSH.execSync read err failed")));
            }
            if (s == 0) {
                // done?
                errDone = true;
                if (outDone)
                    break;
            }
            errData += std::string(buf, s);
        }
    }

    ::close(stdoutPipe[0]);
    ::close(stderrPipe[0]);

    Handle<Object> obj = Object::New();
    if (!outData.empty())
        obj->Set(String::New("stdout"), String::New(outData.c_str(), outData.size()));
    if (!errData.empty())
        obj->Set(String::New("stderr"), String::New(errData.c_str(), errData.size()));

    return obj;
}

void JSH::cleanup()
{
    tcsetattr(STDIN_FILENO, 0, &shellTmodes);
}

JSH::JSH()
    : ObjectWrap()
{
    assert(!sJSH);
    sJSH = this;

    if (::pipe(sJshPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }

    interact = isatty(STDIN_FILENO);
    if (interact) {
        while (tcgetpgrp(STDIN_FILENO) != (shellPgid = getpgrp()))
            kill(-shellPgid, SIGTTIN);

        ::signal(SIGINT, SIG_IGN);
        ::signal(SIGQUIT, SIG_IGN);
        ::signal(SIGTSTP, SIG_IGN);
        ::signal(SIGTTIN, SIG_IGN);
        ::signal(SIGTTOU, SIG_IGN);

        shellPgid = getpid();
        if (setpgid(shellPgid, shellPgid) < 0) {
            fprintf(stderr, "Couldn't put the shell in its own process group");
            abort();
        }

        tcsetpgrp(STDIN_FILENO, shellPgid);
        tcgetattr(STDIN_FILENO, &shellTmodes);
    }
}

JSH::~JSH()
{
    assert(sJSH == this);
    ::close(sJshPipe[0]);
    ::close(sJshPipe[1]);
    sJSH = 0;
}

Handle<Value> JSH::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 0) {
        return ThrowException(Exception::TypeError(String::New("JSH takes no arguments")));
    }

    if (sJSH) {
        return ThrowException(Exception::TypeError(String::New("Can only have one JSH object at a time")));
    }

    JSH* obj = new JSH;

    Handle<ObjectTemplate> templ = ObjectTemplate::New();
    templ->SetInternalFieldCount(1);

    obj->termiosTemplate = Persistent<v8::ObjectTemplate>::New(templ);
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    JSH::init(target);
}

NODE_MODULE(jsh, RegisterModule);
