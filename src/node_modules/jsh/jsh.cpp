#include "jsh.h"
#include <Util.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <sys/select.h>
#include <algorithm>
#include <functional>
#include <mutex>

static JSH* sJSH = 0;
static int sJshPipe[2];
static UVMutex sMutex;

void signal(int s)
{
    int e;
    unsigned char c = static_cast<unsigned char>(s);
    eintrwrap(e, ::write(sJshPipe[1], &c, 1));
}

using namespace v8;
using namespace node;

Persistent<FunctionTemplate> JSH::constructor;

static Handle<Value> GetInteractive(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::Boolean::New(obj->interactive());
}

static Handle<Value> GetPgid(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::Integer::New(obj->pgid());
}

static Handle<Value> GetTermios(Local<v8::String> property, const AccessorInfo& info)
{
    JSH* obj = ObjectWrap::Unwrap<JSH>(info.Holder());
    return v8::External::New(obj->term());
}

void JSH::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("jsh");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    // set up properties
    constructor->InstanceTemplate()->SetAccessor(String::New("interactive"), GetInteractive);
    constructor->InstanceTemplate()->SetAccessor(String::New("pgid"), GetPgid);
    constructor->InstanceTemplate()->SetAccessor(String::New("termios"), GetTermios);

    NODE_SET_PROTOTYPE_METHOD(constructor, "cleanup", cleanup);

    target->Set(name, constructor->GetFunction());
}

Handle<Value> JSH::cleanup(const Arguments& args)
{
    HandleScope scope;

    JSH* obj = ObjectWrap::Unwrap<JSH>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("JSH.cleanup takes no arguments")));
    }
    obj->cleanup();

    return Undefined();
}

void JSH::cleanup()
{
    tcsetattr(STDIN_FILENO, 0, &shellTmodes);
}

/*
void JSH::RunCallback(uv_async_t* handle, int)
{
    unsigned char signal;
    {
        UVMutexLocker locker(sMutex);
        unsigned char* sigptr = static_cast<unsigned char*>(handle->data);
        signal = *sigptr;
        delete sigptr;
    }
    sJSH->handleSignal(signal);
}

void JSH::Run(uv_work_t *req)
{
    // Do work
    fd_set rd;
    int s, fd = sJshPipe[0];
    for (;;) {
        FD_ZERO(&rd);
        FD_SET(fd, &rd);
        eintrwrap(s, ::select(fd + 1, &rd, 0, 0, 0));
        if (s <= 0) {
            fprintf(stderr, "unable to select\n");
            fflush(stderr);
            abort();
            return;
        }
        if (FD_ISSET(fd, &rd)) {
            unsigned char c;
            eintrwrap(s, ::read(fd, &c, 1));
            if (s == 0) {
                // closed
                return;
            }
            if (s < 0) {
                fprintf(stderr, "unable to read\n");
                fflush(stderr);
                abort();
                return;
            }
            if (c == 0) {
                // stopped
                return;
            }

            UVMutexLocker locker(sMutex);
            sJSH->async.data = new unsigned char(c);
            uv_async_send(&sJSH->async);
        }
    }
}

void JSH::Done(uv_work_t *req, int)
{
    uv_close(reinterpret_cast<uv_handle_t*>(&sJSH->async), 0);
}
*/

JSH::JSH()
    : ObjectWrap()
{
    assert(!sJSH);
    sJSH = this;

    if (::pipe(sJshPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }

    interact = isatty(STDIN_FILENO);
    if (interact) {
        while (tcgetpgrp(STDIN_FILENO) != (shellPgid = getpgrp ()))
            kill(-shellPgid, SIGTTIN);

        ::signal(SIGINT, SIG_IGN);
        ::signal(SIGQUIT, SIG_IGN);
        ::signal(SIGTSTP, SIG_IGN);
        ::signal(SIGTTIN, SIG_IGN);
        ::signal(SIGTTOU, SIG_IGN);
        ::signal(SIGCHLD, SIG_IGN);

        shellPgid = getpid();
        if (setpgid(shellPgid, shellPgid) < 0) {
            fprintf(stderr, "Couldn't put the shell in its own process group");
            abort();
        }

        tcsetpgrp(STDIN_FILENO, shellPgid);
        tcgetattr(STDIN_FILENO, &shellTmodes);
    }


    // loop = uv_default_loop();
    // uv_async_init(loop, &async, RunCallback);
    // uv_queue_work(loop, &work, Run, Done);
}

JSH::~JSH()
{
    assert(sJSH == this);
    ::close(sJshPipe[0]);
    ::close(sJshPipe[1]);
    sJSH = 0;
}

// void JSH::handleSignal(unsigned char sig)
// {
//     HandleScope scope;

//     Handle<Value> integer = Integer::New(sig);
//     Handle<Context> ctx = Context::GetCurrent();
//     callback->Call(ctx->Global(), 1, &integer);
// }

Handle<Value> JSH::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 0) {
        return ThrowException(Exception::TypeError(String::New("JSH takes no arguments")));
    }

    // if (args[0].IsEmpty() || !args[0]->IsFunction()) {
    //     return ThrowException(Exception::TypeError(String::New("JSH takes one callback argument")));
    // }

    if (sJSH) {
        return ThrowException(Exception::TypeError(String::New("Can only have one JSH object at a time")));
    }

    JSH* obj = new JSH;
    //obj->callback = Persistent<v8::Function>::New(Handle<v8::Function>::Cast(args[0]));
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    JSH::init(target);
}

NODE_MODULE(jsh, RegisterModule);
