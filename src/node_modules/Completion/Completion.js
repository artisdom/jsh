var Tokenizer = require('Tokenizer');
var fs = require('fs');

function Completion()
{
    this._comps = [];
    this._cmdComps = {};

    this.register(fileCompletion);
    this.register("git", require('./Git'));
    this.register(javascriptCompletion);
}

function tokenize(data, mode)
{
    var tokens = [];

    var tok = new Tokenizer.Tokenizer(mode), token;
    tok.tokenize(data);
    while ((token = tok.next())) {
        tokens.push(token);
    }
    return tokens;
}

function findTokenEntry(tokens, pos, takelast)
{
    for (var idx = 0; idx < tokens.length; ++idx) {
        var entry = tokens[idx];
        for (var sub = 0; sub < entry.length; ++sub) {
            var subentry = entry[sub];
            if (subentry.from === undefined
                || subentry.to === undefined)
                continue;
            if (pos >= subentry.from && pos <= subentry.to)
                return { entry: entry, sub: sub, index: idx };
        }
    }
    if (takelast && tokens.length) {
        // check if we're past the last token
        var last = tokens[tokens.length - 1];
        if (pos >= last[0].from) {
            // yes, return it
            return { entry: last, sub: last.length, index: tokens.length - 1 };
        }
    }
    return undefined;
}

function lowestCommon(strings)
{
    if (!strings.length)
        return undefined;
    var cur = strings[0];
    for (var idx = 1; idx < strings.length; ++idx) {
        // find the matching point
        var len = cur.length;
        while (len > 0 && cur.substr(0, len) !== strings[idx].substr(0, len))
            --len;
        if (!len) {
            // no common point
            return "";
        }
        cur = cur.substr(0, len);
    }
    return cur;
}

Completion.prototype.complete = function(data)
{
    function tryComplete(comps)
    {
        if (comps === undefined)
            return undefined;
        var ret = [], len = comps.length;
        for (var idx = len - 1; idx >= 0; --idx) {
            var c = comps[idx](data);
            if (c instanceof Array) {
                ret = ret.concat(c);
            } else if (typeof c === "object") {
                if (c.exclusive) {
                    ret = c.data;
                    return ret;
                } else if (c.stop) {
                    if (c.data instanceof Array)
                        ret = ret.concat(c.data);
                    return ret;
                }
                if (c.data instanceof Array)
                    ret = ret.concat(c.data);
            } else if (c !== undefined) {
                ret.push(c);
            }
        }
        return (!ret.length) ? undefined : ret;
    }

    var tokens;
    try {
        tokens = tokenize(data.text, Tokenizer.SHELL);
    } catch (e) {
    }

    var ret;
    if (tokens !== undefined) {
        data.tokens = tokens;
        var entry = findTokenEntry(tokens, data.start, true);
        data.entry = entry;
        if (entry !== undefined && entry.sub > 0 && entry.entry[0].type == Tokenizer.COMMAND) {
            // is a command
            if (this._cmdComps.hasOwnProperty(entry.entry[0].data)) {
                ret = tryComplete(this._cmdComps[entry.entry[0].data]);
            } else {
                // check if there are slashes in the completion candidate command
                var cmd = entry.entry[0].data;
                var lastSlash = cmd.lastIndexOf('/');
                if (lastSlash != -1) {
                    ret = tryComplete(this._cmdComps[cmd.substr(lastSlash + 1)]);
                }
            }
            if (ret)
                return ret;
        }
    }
    return tryComplete(this._comps);
};

Completion.prototype.register = function()
{
    var idx = 0;
    var cmd = undefined;
    if (typeof arguments[0] === "string") {
        cmd = arguments[0];
        ++idx;
    }
    if (typeof arguments[idx] !== "function") {
        throw "Completion.register needs a function argument";
    }
    if (cmd !== undefined) {
        if (this._cmdComps[cmd] === undefined)
            this._cmdComps[cmd] = [];
        this._cmdComps[cmd].push(arguments[idx]);
    } else {
        this._comps.push(arguments[idx]);
    }
};


// alts has the following format:
//   alts = { config: {}, options: options }
//   where
//     config.flagsPrecedeCommands = true|false
//     config.optionsIsValue = true|false
//     options is either value or { name: value, ... }
//     where
//       value = { flags: array, flagsWithValues: object, commands: commands }
//       where
//         array = ["--flag1", ...] or a function that returns an array
//         object = { "--flag1": flag } or a function that returns an object
//         where
//           flag = string describing the type
//         commands = ["name", ...], { name: value, ... } or a function that returns a command

function completeArray(data, alts)
{
    if (!(alts instanceof Array))
        return undefined;
    var cur = data.comp;
    var cand = [], idx;
    for (idx = 0; idx < alts.length; ++idx) {
        if (alts[idx] && alts[idx].substr(0, cur.length) == cur) {
            // candidate
            cand.push(alts[idx]);
        }
    }
    if (cand.length === 0)
        return undefined;
    if (cand.length === 1)
        return cand[0];
    // find the lowest common denominator, use the first candidate as a starting point
    cur = lowestCommon(cand);
    cand.splice(0, 0, cur);
    return cand;
}

function CompletionHelper(alts)
{
    this._alts = alts;
}

CompletionHelper.prototype.set = function(alts)
{
    this._alts = alts;
};

CompletionHelper.prototype.completeArray = function(data, alts)
{
    return completeArray(data, alts);
};

CompletionHelper.prototype.complete = function(data)
{
    var tokens;
    try {
        tokens = tokenize(data.text, Tokenizer.SHELL);
    } catch (e) {
        return undefined;
    }
    var entry = findTokenEntry(tokens, data.start, true);
    if (entry === undefined) {
        return undefined;
    }

    if (entry.entry[0].type !== Tokenizer.COMMAND) {
        // not a parsed command
        return undefined;
    }

    // find the subcommand
    var ent = entry.entry;
    var sub = entry.sub;
    var cfg = this._alts.config || {};
    var curalt = this._alts.options, idx;
    if (!cfg.optionsIsValue) {
        for (idx = 1; idx < sub; ++idx) {
            if (ent[idx].type !== Tokenizer.COMMAND) {
                continue;
            }
            var curdata = ent[idx].data;
            // is the current entry an option?
            if (curdata[0] === "-") {
                continue;
            }
            if (curalt.commands instanceof Array) {
                return undefined;
            } else if (typeof curalt.commands === "object") {
                if (curalt.commands.hasOwnProperty(curdata)) {
                    curalt = curalt.commands[curdata];
                } else {
                    return undefined;
                }
            } else {
                // not found, can't proceed
                return undefined;
            }
        }
    }

    var arr;
    var comp = data.comp;
    if (sub > 0 && sub < ent.length) {
        if (ent[sub].data === "=") {
            // find ourselves in curalt.flagsWithValues
            if (!curalt.hasOwnProperty("flagsWithValues"))
                return undefined;
            if (curalt.flagsWithValues.hasOwnProperty(ent[sub - 1].data)) {
                arr = curalt.flagsWithValues[ent[sub - 1].data];
                if (typeof arr === "function")
                    arr = arr(data);
                if (arr instanceof Array)
                    return this.completeArray(data, arr);
                else
                    return undefined;
            } else {
                return undefined;
            }
        }
    }

    // are we completing an option?
    var isflag = (data.comp[0] === "-");
    if (isflag) {
        // yes, grab our flags
        arr = [];
        if (typeof curalt.flags === "function") {
            arr = arr.concat(curalt.flags(data));
        } else if (curalt.flags instanceof Array) {
            for (idx = 0; idx < curalt.flags.length; ++idx) {
                arr.push(curalt.flags[idx]);
            }
        }
        var obj;
        if (typeof curalt.flagsWithValues === "function") {
            obj = curalt.flagsWithValues(data);
        } else if (typeof curalt.flagsWithValues === "object") {
            obj = curalt.flagsWithValues;
        }
        for (var k in obj) {
            if (obj.hasOwnProperty(k))
                arr.push(k);
        }
        var ret = this.completeArray(data, arr);
        if (typeof ret === "string") {
            // if we're a flag with value, append an =
            if (obj && obj.hasOwnProperty(ret)) {
                // but only if the option doesn't have a default value
                arr = obj[ret];
                if (arr instanceof Array) {
                    if (arr[0] === null)
                        return ret;
                    else
                        ret += "=";
                }
            }
        }
        return ret;
    } else {
        // no, let's look at commands
        var cmd = curalt.commands;
        if (typeof cmd === "function")
            cmd = cmd(data);
        if (typeof cmd === "object") {
            if (cmd instanceof Array) {
                return this.completeArray(data, cmd);
            } else {
                // make an array with keys
                arr = [];
                for (var j in cmd) {
                    if (cmd.hasOwnProperty(j))
                        arr.push(j);
                }
                return this.completeArray(data, arr);
            }
        } else {
            return undefined;
        }
    }

    return undefined;
};

function fileCompletion(data, useRelative, pathsOnly)
{
    if (!data.comp.length)
        return undefined;
    if (data.comp[0] === '/' || useRelative) {
        var prefix;
        var comp = data.comp;
        var idx;
        if (comp[0] !== '/') {
            prefix = process.cwd();
            comp = prefix + "/" + comp;
        }
        // absolute path, read the dir
        // first, find the previous directory
        var last = comp.lastIndexOf('/');
        var path = comp.substr(0, last + 1);
        var file = comp.substr(last + 1);
        // get all the files
        try {
            var cands = fs.readdirSync(path);
        } catch (e) {
            return undefined;
        }
        if (file.length > 0) {
            var tmp = [];
            for (idx = 0; idx < cands.length; ++idx) {
                if (cands[idx].substr(0, file.length) === file)
                    tmp.push(cands[idx]);
            }
            cands = tmp;
        }
        if (cands.length > 1) {
            var lowest = lowestCommon(cands);
            cands.splice(0, 0, lowest);
        }
        // append the path
        var lastWasFile = false;
        for (idx = 0; idx < cands.length; ++idx) {
            cands[idx] = path + cands[idx];
            // append slash if file is a directory
            var stats;
            if (cands[idx][cands[idx].length - 1] !== '/') {
                try {
                    stats = fs.statSync(cands[idx]);
                    if (stats.isDirectory()) {
                        lastWasFile = false;
                        cands[idx] += '/';
                    } else {
                        lastWasFile = true;
                    }
                } catch (e) {
                    lastWasFile = false;
                }
            } else {
                // check if we're a file
                try {
                    stats = fs.statSync(cands[idx]);
                    lastWasFile = !stats.isDirectory();
                } catch (e) {
                    lastWasFile = false;
                }
            }
        }
        // fixup
        if (prefix) {
            var len = prefix.length + 1;
            for (idx = 0; idx < cands.length; ++idx) {
                cands[idx] = cands[idx].substr(len);
            }
        }
        // strip files if we asked for paths only
        if (pathsOnly) {
            var rem = [];
            for (idx = 0; idx < cands.length; ++idx) {
                try {
                    stats = fs.statSync(cands[idx]);
                    if (!stats.isDirectory()) {
                        rem.push(idx);
                    }
                } catch (e) {
                    // can't stat? take it out
                    rem.push(idx);
                }
            }
            var off = 0;
            for (idx = 0; idx < rem.length; ++idx) {
                cands.splice(rem[idx] - (off++), 1);
            }
        }
        if (cands.length === 1 && lastWasFile)
            cands[0] += ' ';
        return cands;
    }
    return undefined;
}

function tryExpand(comp, alternatives)
{
    function startsWith(haystack, needle) {
        var i = 0;
        while (i<needle.length && i<haystack.length && haystack[i] !== needle[i]) {
            ++i;
        }
        return i;
    }
    var shortest;
    for (var i=0; i<alternatives.length; ++i) {
        var len = startsWith(alternatives[i], comp);
        if (len && (!shortest || len < shortest)) {
            shortest = len;
        }
    }
}

var keywords = [ "break", "do", "instanceof", "typeof", "case", "else", "new", "var", "catch",
                 "finally", "return", "void", "continue", "for", "switch", "while", "debugger",
                 "function", "this", "with", "default", "if", "throw", "delete", "in", "try",
                 "true", "false", "null", "undefined", "NaN" ];
function javascriptCompletion(data)
{
    var NONE = 0;
    var BRACKET = 1;
    var QUOTED_BRACKET = 2;
    var DOT = 4;

    var tokenizer = new Tokenizer.Tokenizer(Tokenizer.SCRIPT|Tokenizer.TOLERANT);
    tokenizer.tokenize(data.text);
    var obj = global;
    // console.log("\n javascriptCompletion: ", data.text);
    var state = DOT;
    var lastCommand;
    var entries = [];
    while (true) {
        var e = tokenizer.next();
        if (!e)
            break;
        for (var j=0; j<e.length; ++j) {
            var clear = false;
            var tok = e[j];
            if (tok.type === Tokenizer.OPERATOR) {
                switch (tok.data) {
                case '.':
                case '[':
                case ']':
                    break;
                default:
                    clear = true;
                    break;
                }
            }
            if (clear) {
                entries = [];
            } else {
                entries.push(tok);
            }
        }
    }
    // console.log(entries);
    // return undefined;

    var path = "";
    function addObject(name)
    {
        if (obj.hasOwnProperty(name) || obj[name]) {
            // need to test both in case the property is a value that
            // returns false, we also want non-hasOwnProperty things
            // like functions for strings etc
            obj = obj[name];
            if (path) {
                path += "." + name;
            } else {
                path = name;
            }
            return true;
        }

        console.log("No property", name, "on", path);
        return false;
    }
    for (var i=0; i<entries.length; ++i) {
        var token = entries[i];
        // console.log(i, token);
        switch (token.type) {
        case Tokenizer.COMMAND:
        case Tokenizer.QUOTEDCOMMAND:
            lastCommand = token.data;
            break;
        case Tokenizer.HIDDEN:
            if (state === BRACKET && (token.data === '\'' || token.data === '"')) {
                state = QUOTED_BRACKET;
            }
            break;
        case Tokenizer.OPERATOR:
            switch (token.data) {
            case '.':
                if (lastCommand) {
                    if (!addObject(lastCommand))
                        return undefined;
                    lastCommand = undefined;
                }
                state = DOT;
                break;
            case '[':
                if (lastCommand) {
                    if (!addObject(lastCommand))
                        return undefined;
                    lastCommand = undefined;
                }
                state = BRACKET;
                break;
            case ']':
                if (state === QUOTED_BRACKET) {
                    if (!addObject(lastCommand))
                        return undefined;
                    lastCommand = undefined;
                    state = NONE;
                } else {
                    // lastCommand = eval(lastCommand);
                }
                break;
            }
        }
    }
    if (state === NONE)
        return undefined;

    var ret = [""];
    if (state !== QUOTED_BRACKET && path) {
        path += ".";
    }
    function processWord(alt) {
        if (!lastCommand || alt.lastIndexOf(lastCommand) === 0) {
            if (state === QUOTED_BRACKET) {
                ret.push(alt);
            } else {
                ret.push(path + alt);
            }
        }
    }
    for (var alt in obj) {
        processWord(alt);
    }
    if (!path) {
        for (i=0; i<keywords.length; ++i) {
            processWord(keywords[i]);
        }
    }
    if (ret.length === 1) {
        return undefined;
    } else if (ret.length === 2) {
        return ret[1];
    }
    return ret;
}

module.exports = {
    Completion: Completion,
    Helper: CompletionHelper,
    fileCompletion: function(data) { return completeArray(data, fileCompletion(data, true)); },
    dirCompletion: function(data) { return completeArray(data, fileCompletion(data, true, true)); }
};
