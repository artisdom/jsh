var Tokenizer = require('Tokenizer');
var fs = require('fs');

function Completion()
{
    this._comps = [];
    this._cmdComps = {};

    this.register(fileCompletion);
    this.register("git", require('./Git'));
}

function tokenize(data)
{
    var tokens = [];
    var tok = new Tokenizer.Tokenizer(), token;
    tok.tokenize(data);
    while ((token = tok.next())) {
        tokens.push(token);
    }
    return tokens;
}

function findTokenEntry(tokens, pos, takelast)
{
    for (var idx = 0; idx < tokens.length; ++idx) {
        var entry = tokens[idx];
        for (var sub = 0; sub < entry.length; ++sub) {
            var subentry = entry[sub];
            if (subentry.from === undefined
                || subentry.to === undefined)
                continue;
            if ((pos >= subentry.from && pos <= subentry.to)
                || (takelast && idx === tokens.length - 1))
                return { entry: entry, sub: sub };
        }
    }
    return undefined;
}

function lowestCommon(strings)
{
    if (!strings.length)
        return undefined;
    var cur = strings[0];
    for (var idx = 1; idx < strings.length; ++idx) {
        // find the matching point
        var len = cur.length;
        while (len > 0 && cur.substr(0, len) !== strings[idx].substr(0, len))
            --len;
        if (!len) {
            // no common point
            return "";
        }
        cur = cur.substr(0, len);
    }
    return cur;
}

Completion.prototype.complete = function(data)
{
    function tryComplete(comps)
    {
        if (comps === undefined)
            return undefined;
        var ret = [], len = comps.length;
        for (var idx = len - 1; idx >= 0; --idx) {
            var c = comps[idx](data);
            if (c instanceof Array) {
                ret = ret.concat(c);
            } else if (typeof c === "object") {
                if (c.exclusive) {
                    ret = c.data;
                    return ret;
                } else if (c.stop) {
                    if (c.data instanceof Array)
                        ret = ret.concat(c.data);
                    return ret;
                }
                if (c.data instanceof Array)
                    ret = ret.concat(c.data);
            } else if (c !== undefined) {
                ret.push(c);
            }
        }
        return (!ret.length) ? undefined : ret;
    }

    var tokens;
    try {
        tokens = tokenize(data.text);
    } catch (e) {
    }

    var ret;
    if (tokens !== undefined) {
        var entry = findTokenEntry(tokens, data.start, true);
        if (entry !== undefined && entry.entry[0].type == Tokenizer.COMMAND) {
            // is a command
            ret = tryComplete(this._cmdComps[entry.entry[0].data]);
            if (ret)
                return ret;
        }
    }
    return tryComplete(this._comps);
};

Completion.prototype.register = function()
{
    var idx = 0;
    var cmd = undefined;
    if (typeof arguments[0] === "string") {
        cmd = arguments[0];
        ++idx;
    }
    if (typeof arguments[idx] !== "function") {
        throw "Completion.register needs a function argument";
    }
    if (cmd !== undefined) {
        if (this._cmdComps[cmd] === undefined)
            this._cmdComps[cmd] = [];
        this._cmdComps[cmd].push(arguments[idx]);
    } else {
        this._comps.push(arguments[idx]);
    }
};

function CompletionHelper()
{
    this._alts = [];
}

CompletionHelper.prototype.add = function(str)
{
    this._alts.push("" + str);
};

CompletionHelper.prototype.complete = function(data)
{
    var tokens;
    try {
        tokens = tokenize(data.text);
    } catch (e) {
        return undefined;
    }
    var entry = findTokenEntry(tokens, data.start);
    if (entry === undefined) {
        return undefined;
    }

    if (entry.sub !== 0 || entry.entry[entry.sub].type !== Tokenizer.COMMAND) {
        // not the first entry of a parsed command
        return undefined;
    }

    var cur = data.comp;
    var cand = [], idx;
    for (idx = 0; idx < this._alts.length; ++idx) {
        if (this._alts[idx].substr(0, cur.length) == cur) {
            // candidate
            cand.push(this._alts[idx]);
        }
    }
    if (cand.length === 0)
        return undefined;
    if (cand.length === 1)
        return cand[0];
    // find the lowest common denominator, use the first candidate as a starting point
    cur = lowestCommon(cand);
    cand.splice(0, 0, cur);
    return cand;
};

function fileCompletion(data)
{
    if (!data.comp.length)
        return undefined;
    if (data.comp[0] === '/') {
        // absolute path, read the dir
        // first, find the previous directory
        var last = data.comp.lastIndexOf('/');
        var path = data.comp.substr(0, last + 1);
        var file = data.comp.substr(last + 1);
        // get all the files
        try {
            var cands = fs.readdirSync(path);
        } catch (e) {
            return undefined;
        }
        if (file.length > 0) {
            var tmp = [];
            for (var idx = 0; idx < cands.length; ++idx) {
                if (cands[idx].substr(0, file.length) === file)
                    tmp.push(cands[idx]);
            }
            cands = tmp;
        }
        if (cands.length > 1) {
            var lowest = lowestCommon(cands);
            cands.splice(0, 0, lowest);
        }
        // append the path
        var lastWasFile = false;
        for (var idx = 0; idx < cands.length; ++idx) {
            cands[idx] = path + cands[idx];
            // append slash if file is a directory
            if (cands[idx][cands[idx].length - 1] !== '/') {
                try {
                    var stats = fs.statSync(cands[idx]);
                    if (stats.isDirectory()) {
                        lastWasFile = false;
                        cands[idx] += '/';
                    } else {
                        lastWasFile = true;
                    }
                } catch (e) {
                    lastWasFile = false;
                }
            } else {
                // check if we're a file
                try {
                    var stats = fs.statSync(cands[idx]);
                    lastWasFile = !stats.isDirectory();
                } catch (e) {
                    lastWasFile = false;
                }
            }
        }
        if (cands.length === 1 && lastWasFile)
            cands[0] += ' ';
        return cands;
    }
    return undefined;
}

module.exports = {
    Completion: Completion,
    Helper: CompletionHelper
};
