var Tokenizer = require('Tokenizer');
var fs = require('fs');

function Completion()
{
    this._comps = [];
    this._cmdComps = {};

    this.register(fileCompletion);
    this.register("git", require('./Git'));
}

function tokenize(data)
{
    var tokens = [];
    var tok = new Tokenizer.Tokenizer(), token;
    tok.tokenize(data);
    while ((token = tok.next())) {
        tokens.push(token);
    }
    return tokens;
}

function findTokenEntry(tokens, pos, takelast)
{
    for (var idx = 0; idx < tokens.length; ++idx) {
        var entry = tokens[idx];
        for (var sub = 0; sub < entry.length; ++sub) {
            var subentry = entry[sub];
            if (subentry.from === undefined
                || subentry.to === undefined)
                continue;
            if (pos >= subentry.from && pos <= subentry.to)
                return { entry: entry, sub: sub };
        }
    }
    if (takelast) {
        // check if we're past the last token
        var last = tokens[tokens.length - 1];
        if (pos >= last[0].from) {
            // yes, return it
            return { entry: last, sub: last.length };
        }
    }
    return undefined;
}

function lowestCommon(strings)
{
    if (!strings.length)
        return undefined;
    var cur = strings[0];
    for (var idx = 1; idx < strings.length; ++idx) {
        // find the matching point
        var len = cur.length;
        while (len > 0 && cur.substr(0, len) !== strings[idx].substr(0, len))
            --len;
        if (!len) {
            // no common point
            return "";
        }
        cur = cur.substr(0, len);
    }
    return cur;
}

Completion.prototype.complete = function(data)
{
    function tryComplete(comps)
    {
        if (comps === undefined)
            return undefined;
        var ret = [], len = comps.length;
        for (var idx = len - 1; idx >= 0; --idx) {
            var c = comps[idx](data);
            if (c instanceof Array) {
                ret = ret.concat(c);
            } else if (typeof c === "object") {
                if (c.exclusive) {
                    ret = c.data;
                    return ret;
                } else if (c.stop) {
                    if (c.data instanceof Array)
                        ret = ret.concat(c.data);
                    return ret;
                }
                if (c.data instanceof Array)
                    ret = ret.concat(c.data);
            } else if (c !== undefined) {
                ret.push(c);
            }
        }
        return (!ret.length) ? undefined : ret;
    }

    var tokens;
    try {
        tokens = tokenize(data.text);
    } catch (e) {
    }

    var ret;
    if (tokens !== undefined) {
        var entry = findTokenEntry(tokens, data.start, true);
        data.entry = entry;
        if (entry !== undefined && entry.sub > 0 && entry.entry[0].type == Tokenizer.COMMAND) {
            // is a command
            if (this._cmdComps.hasOwnProperty(entry.entry[0].data)) {
                ret = tryComplete(this._cmdComps[entry.entry[0].data]);
            } else {
                // check if there are slashes in the completion candidate command
                var cmd = entry.entry[0].data;
                var lastSlash = cmd.lastIndexOf('/');
                if (lastSlash != -1) {
                    ret = tryComplete(this._cmdComps[cmd.substr(lastSlash + 1)]);
                }
            }
            if (ret)
                return ret;
        }
    }
    return tryComplete(this._comps);
};

Completion.prototype.register = function()
{
    var idx = 0;
    var cmd = undefined;
    if (typeof arguments[0] === "string") {
        cmd = arguments[0];
        ++idx;
    }
    if (typeof arguments[idx] !== "function") {
        throw "Completion.register needs a function argument";
    }
    if (cmd !== undefined) {
        if (this._cmdComps[cmd] === undefined)
            this._cmdComps[cmd] = [];
        this._cmdComps[cmd].push(arguments[idx]);
    } else {
        this._comps.push(arguments[idx]);
    }
};


// alts has the following format:
//   alts = { cmds: { cmd: cmdval, ... }, opts: { opt: opval, ... } }
//   where
//     cmdval is one of null (no value), string (type), array (alternatives), function (callback), object ({ cmd: cmdval, ... })
//     optval is one of null (no value), array (alternatives), function (callback), object ({ opt: opval, ... })

function CompletionHelper(alts)
{
    this._alts = alts;
}

CompletionHelper.prototype.set = function(alts)
{
    this._alts = alts;
};

CompletionHelper.prototype.completeArray = function(data, alts)
{
    var cur = data.comp;
    var cand = [], idx;
    for (idx = 0; idx < alts.length; ++idx) {
        if (alts[idx].substr(0, cur.length) == cur) {
            // candidate
            cand.push(alts[idx]);
        }
    }
    if (cand.length === 0)
        return undefined;
    if (cand.length === 1)
        return cand[0];
    // find the lowest common denominator, use the first candidate as a starting point
    cur = lowestCommon(cand);
    cand.splice(0, 0, cur);
    return cand;
};

CompletionHelper.prototype.complete = function(data)
{
    var tokens;
    try {
        tokens = tokenize(data.text);
    } catch (e) {
        return undefined;
    }
    var entry = findTokenEntry(tokens, data.start, true);
    if (entry === undefined) {
        return undefined;
    }

    if (entry.entry[0].type !== Tokenizer.COMMAND) {
        // not a parsed command
        return undefined;
    }

    // find the subcommand
    var ent = entry.entry;
    var sub = entry.sub;
    var curalt = this._alts;
    var curopt = false;
    for (var idx = 1; idx < sub; ++idx) {
        if (ent[idx].type !== Tokenizer.COMMAND)
            continue;
        // is the current entry an option?
        var curdata = ent[idx].data;
        if (curdata[0] === "-") {
            curopt = true;
            // yes, strip all dashes
            while (curdata[0] === "-")
                curdata = curdata.substr(1);
            if (curalt.opts.hasOwnProperty(curdata)) {
                curalt = curalt.opts[curdata];
            } else {
                // not found, can't proceed
                return undefined;
            }
        } else {
            if (curalt.cmds.hasOwnProperty(ent[idx].data)) {
                // yes, update curalt
                curalt = curalt.cmds[ent[idx].data];
            } else {
                // can't proceed
                return undefined;
            }
        }
    }

    switch (typeof curalt) {
    case "string":
        if (curalt === "file")
            return fileCompletion(data);
        return undefined;
    case "object":
        if (curalt instanceof Array) {
            return this.completeArray(data, curalt);
        } else {
            // build an array
            var arr = [];
            for (var k in curalt.cmds) {
                if (curalt.cmds.hasOwnProperty(k))
                    arr.push(k);
            }
            for (var k in curalt.opts) {
                if (curalt.opts.hasOwnProperty(k)) {
                    if (k.length === 1)
                        arr.push("-" + k);
                    else
                        arr.push("--" + k);
                }
            }
            return this.completeArray(data, arr);
        }
        break;
    case "function":
        var ret = curalt(data);
        if (ret instanceof Array)
            return this.completeArray(data, ret);
        return ret;
    }

    return undefined;
};

function fileCompletion(data)
{
    if (!data.comp.length)
        return undefined;
    if (data.comp[0] === '/') {
        // absolute path, read the dir
        // first, find the previous directory
        var last = data.comp.lastIndexOf('/');
        var path = data.comp.substr(0, last + 1);
        var file = data.comp.substr(last + 1);
        // get all the files
        try {
            var cands = fs.readdirSync(path);
        } catch (e) {
            return undefined;
        }
        if (file.length > 0) {
            var tmp = [];
            for (var idx = 0; idx < cands.length; ++idx) {
                if (cands[idx].substr(0, file.length) === file)
                    tmp.push(cands[idx]);
            }
            cands = tmp;
        }
        if (cands.length > 1) {
            var lowest = lowestCommon(cands);
            cands.splice(0, 0, lowest);
        }
        // append the path
        var lastWasFile = false;
        for (var idx = 0; idx < cands.length; ++idx) {
            cands[idx] = path + cands[idx];
            // append slash if file is a directory
            if (cands[idx][cands[idx].length - 1] !== '/') {
                try {
                    var stats = fs.statSync(cands[idx]);
                    if (stats.isDirectory()) {
                        lastWasFile = false;
                        cands[idx] += '/';
                    } else {
                        lastWasFile = true;
                    }
                } catch (e) {
                    lastWasFile = false;
                }
            } else {
                // check if we're a file
                try {
                    var stats = fs.statSync(cands[idx]);
                    lastWasFile = !stats.isDirectory();
                } catch (e) {
                    lastWasFile = false;
                }
            }
        }
        if (cands.length === 1 && lastWasFile)
            cands[0] += ' ';
        return cands;
    }
    return undefined;
}

module.exports = {
    Completion: Completion,
    Helper: CompletionHelper
};
