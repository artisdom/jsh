var Tokenizer = require('Tokenizer');
var fs = require('fs');

function Completion()
{
    this._comps = [];
    this._cmdComps = {};

    this.register(fileCompletion);
    this.register("git", require('./Git'));
}

function tokenize(data)
{
    var tokens = [];
    var tok = new Tokenizer.Tokenizer(), token;
    tok.tokenize(data);
    while ((token = tok.next())) {
        tokens.push(token);
    }
    return tokens;
}

function findTokenEntry(tokens, pos, takelast)
{
    for (var idx = 0; idx < tokens.length; ++idx) {
        var entry = tokens[idx];
        for (var sub = 0; sub < entry.length; ++sub) {
            var subentry = entry[sub];
            if (subentry.from === undefined
                || subentry.to === undefined)
                continue;
            if (pos >= subentry.from && pos <= subentry.to)
                return { entry: entry, sub: sub };
        }
    }
    if (takelast) {
        // check if we're past the last token
        var last = tokens[tokens.length - 1];
        if (pos >= last[0].from) {
            // yes, return it
            return { entry: last, sub: last.length };
        }
    }
    return undefined;
}

function lowestCommon(strings)
{
    if (!strings.length)
        return undefined;
    var cur = strings[0];
    for (var idx = 1; idx < strings.length; ++idx) {
        // find the matching point
        var len = cur.length;
        while (len > 0 && cur.substr(0, len) !== strings[idx].substr(0, len))
            --len;
        if (!len) {
            // no common point
            return "";
        }
        cur = cur.substr(0, len);
    }
    return cur;
}

Completion.prototype.complete = function(data)
{
    function tryComplete(comps)
    {
        if (comps === undefined)
            return undefined;
        var ret = [], len = comps.length;
        for (var idx = len - 1; idx >= 0; --idx) {
            var c = comps[idx](data);
            if (c instanceof Array) {
                ret = ret.concat(c);
            } else if (typeof c === "object") {
                if (c.exclusive) {
                    ret = c.data;
                    return ret;
                } else if (c.stop) {
                    if (c.data instanceof Array)
                        ret = ret.concat(c.data);
                    return ret;
                }
                if (c.data instanceof Array)
                    ret = ret.concat(c.data);
            } else if (c !== undefined) {
                ret.push(c);
            }
        }
        return (!ret.length) ? undefined : ret;
    }

    var tokens;
    try {
        tokens = tokenize(data.text);
    } catch (e) {
    }

    var ret;
    if (tokens !== undefined) {
        var entry = findTokenEntry(tokens, data.start, true);
        data.entry = entry;
        if (entry !== undefined && entry.sub > 0 && entry.entry[0].type == Tokenizer.COMMAND) {
            // is a command
            if (this._cmdComps.hasOwnProperty(entry.entry[0].data)) {
                ret = tryComplete(this._cmdComps[entry.entry[0].data]);
            } else {
                // check if there are slashes in the completion candidate command
                var cmd = entry.entry[0].data;
                var lastSlash = cmd.lastIndexOf('/');
                if (lastSlash != -1) {
                    ret = tryComplete(this._cmdComps[cmd.substr(lastSlash + 1)]);
                }
            }
            if (ret)
                return ret;
        }
    }
    return tryComplete(this._comps);
};

Completion.prototype.register = function()
{
    var idx = 0;
    var cmd = undefined;
    if (typeof arguments[0] === "string") {
        cmd = arguments[0];
        ++idx;
    }
    if (typeof arguments[idx] !== "function") {
        throw "Completion.register needs a function argument";
    }
    if (cmd !== undefined) {
        if (this._cmdComps[cmd] === undefined)
            this._cmdComps[cmd] = [];
        this._cmdComps[cmd].push(arguments[idx]);
    } else {
        this._comps.push(arguments[idx]);
    }
};


// alts has the following format:
//   alts = { config: {}, options: options }
//   where
//     config.flagsPrecedeCommands = true|false
//     config.optionsIsValue = true|false
//     options is either value or { name: value, ... }
//     where
//       value = { flags: array, flagsWithValues: object, commands: commands }
//       where
//         array = ["--flag1", ...] or a function that returns an array
//         object = { "--flag1": flag } or a function that returns an object
//         where
//           flag = string describing the type
//         commands = ["name", ...], { name: value, ... } or a function that returns a command

function CompletionHelper(alts)
{
    this._alts = alts;
}

CompletionHelper.prototype.set = function(alts)
{
    this._alts = alts;
};

CompletionHelper.prototype.completeArray = function(data, alts)
{
    var cur = data.comp;
    var cand = [], idx;
    for (idx = 0; idx < alts.length; ++idx) {
        if (alts[idx].substr(0, cur.length) == cur) {
            // candidate
            cand.push(alts[idx]);
        }
    }
    if (cand.length === 0)
        return undefined;
    if (cand.length === 1)
        return cand[0];
    // find the lowest common denominator, use the first candidate as a starting point
    cur = lowestCommon(cand);
    cand.splice(0, 0, cur);
    return cand;
};

CompletionHelper.prototype.complete = function(data)
{
    var tokens;
    try {
        tokens = tokenize(data.text);
    } catch (e) {
        return undefined;
    }
    var entry = findTokenEntry(tokens, data.start, true);
    if (entry === undefined) {
        return undefined;
    }

    if (entry.entry[0].type !== Tokenizer.COMMAND) {
        // not a parsed command
        return undefined;
    }

    // find the subcommand
    var ent = entry.entry;
    var sub = entry.sub;
    var cfg = this._alts.config || {};
    var curalt = this._alts.options, idx;
    if (!cfg.optionsIsValue) {
        for (idx = 1; idx < sub; ++idx) {
            if (ent[idx].type !== Tokenizer.COMMAND)
                continue;
            var curdata = ent[idx].data;
            // is the current entry an option?
            if (curdata[0] === "-") {
                continue;
            }
            if (curalt.commands instanceof Array) {
                return undefined;
            } else if (typeof curalt.commands === "object") {
                if (curalt.commands.hasOwnProperty(curdata)) {
                    curalt = curalt.commands[curdata];
                } else {
                    return undefined;
                }
            } else {
                // not found, can't proceed
                return undefined;
            }
        }
    }

    // are we completing an option?
    var isflag = (data.comp[0] === "-");
    if (isflag) {
        // yes, grab our flags
        var arr = [];
        if (typeof curalt.flags === "function") {
            arr = arr.concat(curalt.flags(data));
        } else if (curalt.flags instanceof Array) {
            for (idx = 0; idx < curalt.flags.length; ++idx) {
                arr.push(curalt.flags[idx]);
            }
        }
        var obj;
        if (typeof curalt.flagsWithValues === "function") {
            obj = curalt.flagsWithValues(data);
        } else if (typeof curalt.flagsWithValues === "object") {
            obj = curalt.flagsWithValues;
        }
        for (var k in obj) {
            if (obj.hasOwnProperty(k))
                arr.push(k);
        }
        return this.completeArray(data, arr);
    } else {
        // no, let's look at commands
        var cmd = curalt.commands;
        if (typeof cmd === "function")
            cmd = cmd(data);
        if (typeof cmd === "object") {
            if (cmd instanceof Array) {
                return this.completeArray(data, cmd);
            } else {
                // make an array with keys
                var arr = [];
                for (var k in cmd) {
                    if (cmd.hasOwnProperty(k))
                        arr.push(k);
                }
                return this.completeArray(data, arr);
            }
        } else {
            return undefined;
        }
    }

    return undefined;
};

function fileCompletion(data)
{
    if (!data.comp.length)
        return undefined;
    if (data.comp[0] === '/') {
        // absolute path, read the dir
        // first, find the previous directory
        var last = data.comp.lastIndexOf('/');
        var path = data.comp.substr(0, last + 1);
        var file = data.comp.substr(last + 1);
        // get all the files
        try {
            var cands = fs.readdirSync(path);
        } catch (e) {
            return undefined;
        }
        if (file.length > 0) {
            var tmp = [];
            for (var idx = 0; idx < cands.length; ++idx) {
                if (cands[idx].substr(0, file.length) === file)
                    tmp.push(cands[idx]);
            }
            cands = tmp;
        }
        if (cands.length > 1) {
            var lowest = lowestCommon(cands);
            cands.splice(0, 0, lowest);
        }
        // append the path
        var lastWasFile = false;
        for (var idx = 0; idx < cands.length; ++idx) {
            cands[idx] = path + cands[idx];
            // append slash if file is a directory
            if (cands[idx][cands[idx].length - 1] !== '/') {
                try {
                    var stats = fs.statSync(cands[idx]);
                    if (stats.isDirectory()) {
                        lastWasFile = false;
                        cands[idx] += '/';
                    } else {
                        lastWasFile = true;
                    }
                } catch (e) {
                    lastWasFile = false;
                }
            } else {
                // check if we're a file
                try {
                    var stats = fs.statSync(cands[idx]);
                    lastWasFile = !stats.isDirectory();
                } catch (e) {
                    lastWasFile = false;
                }
            }
        }
        if (cands.length === 1 && lastWasFile)
            cands[0] += ' ';
        return cands;
    }
    return undefined;
}

module.exports = {
    Completion: Completion,
    Helper: CompletionHelper
};
