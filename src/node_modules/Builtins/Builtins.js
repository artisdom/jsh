function jobs() {
    var Job = jsh.Job;
    for (var idx = 0; idx < Job.Jobs.length; ++idx) {
        var entry = Job.Jobs[idx];
        var status = "undefined";
        switch (entry.status) {
        case Job.RUNNING:
            status = "running";
            break;
        case Job.STOPPED:
            status = "stopped";
            break;
        case Job.TERMINATED:
            status = "terminated";
            break;
        }
        console.log("[" + (idx + 1) + "]  " + status + "  " + entry.toString());
    }
}

function fg(idx) {
    var Job = jsh.Job;
    if (idx === undefined)
        idx = Job.Jobs.length;
    if (typeof idx !== "number") {
        throw "Invalid index " + idx;
    }
    --idx;
    if (idx < 0 || idx >= Job.Jobs.length) {
        throw "Invalid index " + (idx + 1);
    }
    var entry = Job.Jobs[idx];
    if (entry.type !== Job.BACKGROUND && entry.status === Job.RUNNING) {
        throw "Job already running in foreground, shouldn't happen";
    }
    entry.cont(Job.FOREGROUND);

    return { jsh: { wait: true } };
}

function bg(idx) {
    var Job = jsh.Job;
    if (idx === undefined)
        idx = 1;
    if (typeof idx !== "number") {
        throw "Invalid index " + idx;
    }
    --idx;
    if (idx < 0 || idx >= Job.Jobs.length) {
        throw "Invalid index " + (idx + 1);
    }
    var entry = Job.Jobs[idx];
    if (entry.type !== Job.FOREGROUND && entry.status === Job.RUNNING) {
        console.log("Job already backgrounded");
    }
    entry.cont(Job.BACKGROUND);
}

function disown(idx) {
    var Job = jsh.Job;
    if (idx === undefined)
        idx = 1;
    if (typeof idx !== "number") {
        throw "Invalid index " + idx;
    }
    --idx;
    if (idx < 0 || idx >= Job.Jobs.length) {
        throw "Invalid index " + (idx + 1);
    }
    Job.Jobs.splice(idx, 1);
}

var prevDir;
function chdir(dir) {
    if (dir === '-') {
        // previous
        if (prevDir !== undefined) {
            var dest = prevDir;
            prevDir = process.cwd();
            process.chdir(dest);
            console.log(dest);
        }
        return;
    }
    prevDir = process.cwd();
    process.chdir(dir);
}

function pwd() {
    console.log(process.cwd());
}

module.exports = {
    jobs: jobs,
    fg: fg,
    bg: bg,
    cd: chdir,
    chdir: chdir,
    pwd: pwd,
    disown: disown
};

var Completion = require('Completion');
var helper = new Completion.Helper();

(function() {
    var compobj = { options: { commands: [] }, config: { optionsIsValue: true } };
    for (var i in module.exports) {
        compobj.options.commands.push(i);
    }
    helper.set(compobj);
})();

jsh.completion.register(function(data) {
    var cands = helper.complete(data);
    if (typeof cands === "string")
        cands += " ";
    else if (typeof cands === "object" && cands.length === 1)
        cands[0] += " ";
    return cands;
});

jsh.completion.register("cd", function(data) {
    return Completion.dirCompletion(data);
});
