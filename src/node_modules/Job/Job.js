var pc = require('ProcessChain');
var allJobs = [];

function Input(data)
{
    this._pos = 0;
    this._data = data;
    this._callbacks = {};
}

Input.prototype = {
    read: function() {
        var len;
        var remainder = this._data.length - this._pos;
        switch (arguments.length) {
        case 0:
            len = remainder;
            break;
        case 1:
            len = arguments[0] > remainder ? remainder : arguments[0];
            break;
        default:
            throw "Invalid arguments to Input.read";
        }
        var ret = this._data.substr(this._pos, len);
        this._pos += len;
        return ret;
    },

    write: function(data) {
        if (!this._data || !this._data.length) {
            this._data = data;
        } else {
            this._data += data;
        }
        if (this._callbacks.data) {
            this._callbacks.data.call(this);
        }
    },

    on: function(event, callback) {
        if (callback) {
            this._callbacks[event] = callback;
            if (event === 'data' && this.remaining)
                this._callbacks.data.call(this);
        } else {
            delete this._callbacks[event];
        }
    },

    readLine: function() {
        var idx = this._data.indexOf('\n', this._pos);
        if (idx == -1) {
            return this.read();
        } else {
            var ret = this.read(idx - this._pos);
            ++this._pos;
            return ret;
        }
    },

    peekLine: function() {
        var idx = this._data.indexOf('\n', this._pos);
        if (idx == -1) {
            return this.data.substr(this._pos);
        } else {
            return this.data.substr(this._pos, idx - this._pos);
        }
    },

    get position() {
        return this._pos;
    },

    get remaining() {
        return (this._data ? this._data.length : 0) - this._pos;
    },

    get data() {
        return this.data;
    }
};

function Output(handler)
{
    this._handler = handler;
    this._buffer = "";
};

Output.prototype = {
    write: function() {
        this._handler.write.apply(this, arguments);
    }
};

function JavaScript(func)
{
    if (typeof func === "function")
        this.exec = func;
    this._next = undefined;
    this._data = undefined;
    this._written = false;
}

// Should be overridden
JavaScript.prototype.exec = function(data)
{
    return data;
};

JavaScript.prototype.chain = function(js)
{
    var obj = this;
    while (obj._next !== undefined)
        obj = obj._next;
    obj._next = js;
};

JavaScript.prototype.write = function(data)
{
    var that = this;
    var stdin = new Input(data);
    function toString(arg) {
        var ret;
        try {
            ret = JSON.stringify(arg);
        } catch (err) {
            ret = arg.toString();
        }
        return ret;
    }
    var stdout = {
        write: function() {
            for (var i=0; i<arguments.length; ++i) {
                if (i)
                    that._data += ' ';
                that._data += toString(arguments[i]);
            }
            that._data += '\n';
        },
        writeRaw: function() {
            for (var i=0; i<arguments.length; ++i) {
                that._data += arguments[i];
            }
        }
    };
    var stderr = undefined;
    var io = {
        stdin: stdin,
        stdout: stdout,
        stderr: stderr
    };
    try {
        var r = this.exec(io, this._stdin, stdout, stderr);
        if (this._next)
            this._next.write(r);
        else
            this._data = r;
    } catch (err) {
        console.error("Caught error running js", err.toString());
    }
    this._written = true;
};

JavaScript.prototype.end = function(callback)
{
    var obj = this;

    if (!this._written)
        this.write();

    while (obj._next !== undefined)
        obj = obj._next;
    callback(obj._data);
    obj._data = undefined;
};

JavaScript.prototype.isLast = function()
{
    return (this._next === undefined);
};

function Job()
{
    this._jobs = [];
    this._chains = [];
    this._currentJob = undefined;
}

Job.prototype.toString = function()
{
    if (this._currentJob === undefined) {
        throw "Job not started yet, this shouldn't happen";
    }
    if (this._currentJob < 0 || this._currentJob >= this._jobs.length) {
        throw "_currentJob out of range, " + this._currentJob + " vs " + this._jobs.length;
    }

    var sub = this._jobs[this._currentJob];
    if (sub.type === "process") {
        return sub.jobs[0].program;
    } else if (sub.type === "js") {
        return JSON.stringify(sub.job);
    } else {
        throw "Unknown job type " + sub.type;
    }
};

Job.prototype.cont = function(type)
{
    if (this._currentJob === undefined) {
        throw "Job not started yet, this shouldn't happen";
    }
    if (this._currentJob < 0 || this._currentJob >= this._jobs.length) {
        throw "_currentJob out of range, " + this._currentJob + " vs " + this._jobs.length;
    }

    var sub = this._jobs[this._currentJob];
    if (sub.type === "process") {
        if (sub._pchain === undefined) {
            throw "_pchain is undefined";
        }
        this.type = type;
        this.status = 0; // 0 = RUNNING
        sub._pchain.cont(type);
    } else {
        throw "Can't continue JavaScript jobs";
    }
};

Job.prototype.process = function(process)
{
    // try to find the program
    if (typeof process.program !== "string") {
        throw "Undefined program";
    }
    process.program = jsh.pathify(process.program);

    var idx = this._jobs.length;
    if (this._jobs.length === 0 || this._jobs[idx - 1].type !== "process")
        this._jobs.push({type: "process", jobs: [process]});
    else
        this._jobs[idx - 1].jobs.push(process);
    return this;
};

Job.prototype.proc = Job.prototype.process;

Job.prototype.js = function(js)
{
    if (!(js instanceof JavaScript))
        return this;
    js._next = undefined;

    var idx = this._jobs.length;
    if (this._jobs.length === 0 || this._jobs[idx - 1].type !== "js")
        this._jobs.push({type: "js", job: js});
    else
        this._jobs[idx - 1].job.chain(js);
    return this;
};

Job.prototype.exec = function(type, outCallback, doneCallback)
{
    // set job status to RUNNING
    this.status = 0;
    // add to list of jobs
    allJobs.push(this);
    // go!
    this._runJobsFrom(0, type, outCallback, doneCallback);
};

Job.prototype.cleanup = function()
{
    var sub = this._jobs[this._currentJob];
    if (sub.type === "process") {
        if (sub._pchain === undefined) {
            throw "_pchain is undefined";
        }
        sub._pchain.cleanup();
    }
};

Job.prototype._update = function(status)
{
    if (status === 2) { // TERMINATED
        var idx = allJobs.indexOf(this);
        if (idx === -1) {
            throw "Job not in allJobs";
        }
        allJobs.splice(idx, 1);
        this.status = undefined;
    } else {
        this.status = status;
    }
};

Job.prototype._runJobsFrom = function(pos, type, outCallback, doneCallback, jchain)
{
    this.type = type;
    var that = this;
    var pchain, lastJob;
    for (var i = pos; i < this._jobs.length; ++i) {
        this._currentJob = i;
        lastJob = (i == this._jobs.length - 1);
        var job = this._jobs[i];
        if (job.type === "process") {
            pchain = new pc.ProcessChain(jsh.jshNative, type);
            job._pchain = pchain;
            for (var j in job.jobs) {
                pchain.chain(job.jobs[j]);
            }
            if (jchain) {
                jchain.end(function(data) { pchain.write(data); });
                jchain = undefined;
            }
        } else {
            jchain = job.job;
            if (pchain) {
                // exec process, wait until complete before continuing chain
                pchain.exec(function(data) {
                    if (data.type === "stdout") {
                        jchain.write(data.data);
                    } else {
                        if (!lastJob) { // complete, continue chain now
                            that._runJobsFrom(i + 1, type, outCallback, doneCallback, jchain);
                        } else {
                            jchain.end(outCallback);
                            if (doneCallback) {
                                that._update(data.status);
                                doneCallback(data.code);
                            }
                        }
                    }
                });
                return;
            }
        }
    }
    if (jchain) {
        jchain.end(outCallback);
        if (doneCallback) {
            that._update(2); // 2 = TERMINATED
            // ### Final JS chain always returns success?
            doneCallback(0);
        }
    } else if (pchain) {
        pchain.exec(function(data) {
            if (data.type === "stdout") {
                outCallback(data.data);
            } else { // complete, tell JS we're done
                if (doneCallback) {
                    that._update(data.status);
                    doneCallback(data.code);
                }
            }
        });
    }
};

function cleanup()
{
    for (var idx = 0; idx < allJobs.length; ++idx) {
        allJobs[idx].cleanup();
    }
}

module.exports = {
    Job: Job,
    Jobs: allJobs,
    JavaScript: JavaScript,
    cleanup: cleanup,
    FOREGROUND: 0,
    BACKGROUND: 1,
    RUNNING: 0,
    STOPPED: 1,
    TERMINATED: 2
};
