var pc = require('ProcessChain');
var allJobs = [];

function End(write, done)
{
    this.write = write;
    this.exec = function(out) { done(0); };
}

function JavaScript(func)
{
    if (typeof func !== "function") {
        throw "JavaScript requires a function argument";
    }
    this._generator = func;
    this._iterator = undefined;
    this._next = undefined;
    this._input = "";
    this._inputPos = 0;
    this._done = false;
}

JavaScript.prototype.chain = function(js)
{
    var obj = this;
    while (obj._next !== undefined)
        obj = obj._next;
    obj._next = js;
};

JavaScript.prototype.exec = function(out)
{
    if (!this._done) {
        if (!this._iterator)
            this._iterator = this._generator();
        var ret;
        do {
            ret = this._iterator.next(undefined);
            if (ret.value !== undefined) {
                out({ type: "stdout", data: "" + ret.value });
            }
        } while (!ret.done);
    }
    out({ type: "child", status: 0 });
};

// function* foo()
// {
//     var sum = 0;
//     var data;
//     while ((data = yield undefined) !== undefined)
//         sum += parseInt(data);
//     return sum;
// }

JavaScript.prototype.write = function(data)
{
    if (this._done)
        return;
    var that = this;
    this._input += data;
    if (!this._iterator)
        this._iterator = this._generator();

    while (this._inputPos < this._input.length) {
        var idx = this._input.indexOf(jsh.IFS, this._inputPos);
        if (idx === -1)
            break;
        var chunk = this._input.substring(this._inputPos, idx);
        this._inputPos = idx;
        var out = this._iterator.next(chunk);
        if (out.value !== undefined) {
            this._next.write("" + out.value);
        }
        if (out.done) {
            this._done = true;
            break;
        }
    }
};

function Job()
{
    this._jobs = [];
    this._chains = [];
    this._currentJob = undefined;
}

Job.prototype.toString = function()
{
    if (this._currentJob === undefined) {
        throw "Job not started yet, this shouldn't happen";
    }
    if (this._currentJob < 0 || this._currentJob >= this._jobs.length) {
        throw "_currentJob out of range, " + this._currentJob + " vs " + this._jobs.length;
    }

    var sub = this._jobs[this._currentJob];
    if (sub.type === "process") {
        return sub.jobs[0].program;
    } else if (sub.type === "js") {
        return JSON.stringify(sub.job);
    } else {
        throw "Unknown job type " + sub.type;
    }
};

Job.prototype.cont = function(type)
{
    if (this._currentJob === undefined) {
        throw "Job not started yet, this shouldn't happen";
    }
    if (this._currentJob < 0 || this._currentJob >= this._jobs.length) {
        throw "_currentJob out of range, " + this._currentJob + " vs " + this._jobs.length;
    }

    var sub = this._jobs[this._currentJob];
    if (sub.type === "process") {
        if (sub.entry === undefined) {
            throw "pchain is undefined";
        }
        this.type = type;
        this.status = 0; // 0 = RUNNING
        sub.entry.cont(type);
    } else {
        throw "Can't continue JavaScript jobs";
    }
};

Job.prototype.process = function(process)
{
    // try to find the program
    if (typeof process.program !== "string") {
        throw "Undefined program";
    }
    process.program = jsh.pathify(process.program);

    var idx = this._jobs.length;
    if (this._jobs.length === 0 || this._jobs[idx - 1].type !== "process") {
        var p = { type: "process", entry: new pc.ProcessChain(jsh.jshNative) };
        p.entry.chain(process);
        this._jobs.push(p);
    } else {
        this._jobs[idx - 1].entry.chain(process);
    }
    return this;
};

Job.prototype.proc = Job.prototype.process;

Job.prototype.js = function(js)
{
    if (!(js instanceof JavaScript))
        return this;

    this._jobs.push({ type: "js", entry: js });
    return this;
};

Job.prototype.exec = function(type, outCallback, doneCallback)
{
    if (this._jobs.length === 0) {
        throw "Tried to start a job with no entries";
    }

    // set job status to RUNNING
    this.status = 0;
    // add to list of jobs
    allJobs.push(this);
    this._jobs.push({ type: "end", entry: new End(outCallback, doneCallback) });
    // go!
    this.type = type;
    this._runChain();
};

Job.prototype._runChain = function() {
    for (var i = 0; i < this._jobs.length - 1; ++i) {
        var job = this._jobs[i];
        job._next = this._jobs[i + 1];
        job.entry.type = this.type;
    }
    this._runJob(this._jobs[0]);
};

Job.prototype._runJob = function(job) {
    // run and send output to job._next
    var that = this;
    job.entry.exec(function(data) {
        if (data.type === "stdout") {
            job._next.entry.write(data.data);
        } else {
            that._runJob(job._next);
        }
    });
};

Job.prototype.cleanup = function()
{
    var sub = this._jobs[this._currentJob];
    if (sub.type === "process") {
        if (sub.entry === undefined) {
            throw "pchain is undefined";
        }
        sub.entry.cleanup();
    }
};

Job.prototype._update = function(status)
{
    if (status === 2) { // TERMINATED
        var idx = allJobs.indexOf(this);
        if (idx === -1) {
            throw "Job not in allJobs";
        }
        allJobs.splice(idx, 1);
        this.status = undefined;
    } else {
        this.status = status;
    }
};

function cleanup()
{
    for (var idx = 0; idx < allJobs.length; ++idx) {
        allJobs[idx].cleanup();
    }
}

module.exports = {
    Job: Job,
    Jobs: allJobs,
    JavaScript: JavaScript,
    cleanup: cleanup,
    UNKNOWN: 0,
    FOREGROUND: 1,
    BACKGROUND: 2,
    RUNNING: 0,
    STOPPED: 1,
    TERMINATED: 2
};
