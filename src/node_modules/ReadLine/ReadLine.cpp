#include "ReadLine.h"
#include "Util.h"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <langinfo.h>
#include <sys/types.h>
#include <algorithm>
#include <functional>
#include <utf8.h>
#include <mutex>
#include <readline/readline.h>
#include <readline/history.h>

static std::once_flag isUtf8Flag;
static bool isUtf8 = false;

using namespace v8;

Persistent<FunctionTemplate> ReadLine::constructor;

void ReadLine::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("ReadLine");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    NODE_SET_PROTOTYPE_METHOD(constructor, "cleanup", cleanup);
    NODE_SET_PROTOTYPE_METHOD(constructor, "resume", resume);

    target->Set(name, constructor->GetFunction());
}

static UVMutex* mutex = 0;
static bool jsDone = false;
static UVCondition* jsCond = 0;
static bool finDone = false;
static UVCondition* finCond = 0;
static ReadLine* sReadLine = 0;

void ReadLine::RunCallback(uv_async_t* handle, int /*status*/)
{
    char* line = 0;
    {
        UVMutexLocker locker(*mutex);
        line = static_cast<char*>(handle->data);
    }

    sReadLine->handleLine(line);
}

static inline bool isUnicodeSpace(uint32_t cp)
{
    switch (cp) {
    case 0x0009:
    case 0x000A:
    case 0x000B:
    case 0x000C:
    case 0x000D:
    case 0x0020:
    case 0x0085:
    case 0x00A0:
    case 0x1680:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200A:
    case 0x2028:
    case 0x2029:
    case 0x202F:
    case 0x205F:
    case 0x3000:
        return true;
    }
    return false;
}

char* stripwhite(char* string)
{
    if (!string || !isUtf8)
        return string;

    uint32_t cp;
    char* end = string + strlen(string);
    char* prevString = string;
    while (string < end) {
        cp = utf8::unchecked::next(string);
        if (!isUnicodeSpace(cp))
            break;
        prevString = string;
    }
    string = prevString;

    char* prevEnd = end;
    while (end > string) {
        cp = utf8::unchecked::prior(end);
        if (!isUnicodeSpace(cp))
            break;
        prevEnd = end;
    }
    end = prevEnd;

    if (string == end) {
        // all spaces;
        return end;
    }

    *end = '\0';
    return string;
}

void ReadLine::handleReadLine(char* line)
{
    if (line && !*line)
        return;

    if (line)
        add_history(line);

    UVMutexLocker locker(*mutex);
    sReadLine->async.data = stripwhite(line);
    uv_async_send(&sReadLine->async);

    while (!jsDone) {
        jsCond->wait(*mutex);
    }
    jsDone = false;

    if (line)
        free(line);
}

void ReadLine::Run(uv_work_t *req)
{
    rl_callback_handler_install("hello: ", handleReadLine);

    const int p = sReadLine->rlPipe[0];
    fd_set rd;
    int e;
    int max = std::max(STDIN_FILENO, p);
    for (;;) {
        FD_ZERO(&rd);
        FD_SET(STDIN_FILENO, &rd);
        FD_SET(p, &rd);
        eintrwrap(e, ::select(max + 1, &rd, 0, 0, 0));
        if (e <= 0) {
            fprintf(stderr, "select failed %d %d\n", e, errno);
            fflush(stderr);
            abort();
        }
        if (FD_ISSET(p, &rd)) {
            char c;
            eintrwrap(e, ::read(p, &c, 1));
            if (e < 0) {
                fprintf(stderr, "read failed %d\n", errno);
                fflush(stderr);
                abort();
            }
            if (!e || c == 'q')
                break;
        }
        if (FD_ISSET(STDIN_FILENO, &rd)) {
            rl_callback_read_char();
        }
    }

    rl_callback_handler_remove();

    UVMutexLocker locker(*mutex);
    finDone = true;
    finCond->broadcast();
}

void ReadLine::Done(uv_work_t *req, int /*status*/)
{
    uv_close(reinterpret_cast<uv_handle_t*>(&sReadLine->async), 0);
}

ReadLine::ReadLine()
    : ObjectWrap()
{
    assert(!sReadLine);
    sReadLine = this;

    std::call_once(isUtf8Flag, []() { setlocale(LC_ALL, ""); if (!strcmp(nl_langinfo(CODESET), "UTF-8")) isUtf8 = true; });

    mutex = new UVMutex;
    jsCond = new UVCondition;
    finCond = new UVCondition;
    jsDone = finDone = false;

    if (::pipe(rlPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }
    loop = uv_default_loop();
    uv_async_init(loop, &async, RunCallback);
    uv_queue_work(loop, &work, Run, Done);
}

ReadLine::~ReadLine()
{
    cleanup();
}

void ReadLine::handleLine(char* line)
{
    HandleScope scope;

    Handle<Value> str = line ? String::New(line) : Undefined();
    Handle<Context> ctx = Context::GetCurrent();
    callback->Call(ctx->Global(), 1, &str);
}

void ReadLine::cleanup()
{
    if (!sReadLine)
        return;

    int w;
    int fd = rlPipe[1];
    eintrwrap(w, ::write(fd, "q", 1));

    UVMutexLocker locker(*mutex);
    if (!finDone && !jsDone) {
        jsDone = true;
        jsCond->signal();
    }

    while (!finDone) {
        finCond->wait(*mutex);
    }

    ::close(rlPipe[0]);
    ::close(rlPipe[1]);

    locker.unlock();
    delete mutex;
    delete finCond;
    delete jsCond;

    sReadLine = 0;
}

Handle<Value> ReadLine::cleanup(const Arguments& args)
{
    HandleScope scope;

    ReadLine* obj = ObjectWrap::Unwrap<ReadLine>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("ReadLine.cleanup takes no arguments")));
    }
    obj->cleanup();

    return Undefined();
}

Handle<Value> ReadLine::resume(const Arguments& args)
{
    HandleScope scope;

    //ReadLine* obj = ObjectWrap::Unwrap<ReadLine>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("ReadLine.resume takes no arguments")));
    }

    UVMutexLocker locker(*mutex);
    assert(!jsDone);

    jsDone = true;
    jsCond->signal();

    return Undefined();
}

Handle<Value> ReadLine::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one callback argument")));
    }

    if (args[0].IsEmpty() || !args[0]->IsFunction()) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one callback argument")));
    }

    if (sReadLine) {
        return ThrowException(Exception::TypeError(String::New("Can only have one ReadLine object at a time")));
    }

    ReadLine* obj = new ReadLine;
    obj->callback = Persistent<v8::Function>::New(Handle<v8::Function>::Cast(args[0]));
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    ReadLine::init(target);
}

NODE_MODULE(ReadLine, RegisterModule);
