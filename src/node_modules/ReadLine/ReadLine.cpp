#include "ReadLine.h"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <langinfo.h>
#include <sys/types.h>
#include <algorithm>
#include <functional>
#include <utf8.h>
#include <mutex>
#include <readline/readline.h>
#include <readline/history.h>

static std::once_flag isUtf8Flag;
static bool isUtf8 = false;

class UVMutex
{
public:
    UVMutex()
    {
        uv_mutex_init(&mutex);
    }
    ~UVMutex()
    {
        uv_mutex_destroy(&mutex);
    }

    void lock()
    {
        uv_mutex_lock(&mutex);
    }
    void unlock()
    {
        uv_mutex_unlock(&mutex);
    }

private:
    uv_mutex_t mutex;

    friend class UVCondition;
};

class UVCondition
{
public:
    UVCondition()
    {
        uv_cond_init(&cond);
    }
    ~UVCondition()
    {
        uv_cond_destroy(&cond);
    }

    void wait(UVMutex& mutex)
    {
        uv_cond_wait(&cond, &mutex.mutex);
    }
    void signal()
    {
        uv_cond_signal(&cond);
    }
    void broadcast()
    {
        uv_cond_broadcast(&cond);
    }

private:
    uv_cond_t cond;
};

class UVMutexLocker
{
public:
    UVMutexLocker(UVMutex& mutex)
        : m(mutex), locked(true)
    {
        m.lock();
    }
    ~UVMutexLocker()
    {
        if (locked)
            m.unlock();
    }

    void unlock()
    {
        if (locked) {
            m.unlock();
            locked = false;
        }
    }

private:
    UVMutex& m;
    bool locked;
};

#define eintrwrap(VAR, BLOCK)                   \
    do {                                        \
        VAR = BLOCK;                            \
    } while (VAR == -1 && errno == EINTR)

using namespace v8;

Persistent<FunctionTemplate> ReadLine::constructor;

void ReadLine::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("ReadLine");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    NODE_SET_PROTOTYPE_METHOD(constructor, "cleanup", cleanup);

    target->Set(name, constructor->GetFunction());
}

struct CallbackData
{
    static UVMutex* mutex;
    static UVCondition* cond;
    static bool done;

    char* line;
};

UVMutex* CallbackData::mutex;
UVCondition* CallbackData::cond;
bool CallbackData::done;

static ReadLine* sReadLine = 0;

void ReadLine::RunCallback(uv_async_t* handle, int /*status*/)
{
    UVMutexLocker locker(*CallbackData::mutex);
    CallbackData* data = static_cast<CallbackData*>(handle->data);
    char* line = data->line;

    if (!line) {
        CallbackData::done = true;
        CallbackData::cond->signal();
        locker.unlock();
    }

    sReadLine->handleLine(line);

    if (line) {
        CallbackData::done = true;
        CallbackData::cond->signal();
    }
}

static inline bool isUnicodeSpace(uint32_t cp)
{
    switch (cp) {
    case 0x0009:
    case 0x000A:
    case 0x000B:
    case 0x000C:
    case 0x000D:
    case 0x0020:
    case 0x0085:
    case 0x00A0:
    case 0x1680:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200A:
    case 0x2028:
    case 0x2029:
    case 0x202F:
    case 0x205F:
    case 0x3000:
        return true;
    }
    return false;
}

char* stripwhite(char* string)
{
    if (!string || !isUtf8)
        return string;

    uint32_t cp;
    char* end = string + strlen(string);
    char* prevString = string;
    while (string < end) {
        cp = utf8::unchecked::next(string);
        if (!isUnicodeSpace(cp))
            break;
        prevString = string;
    }
    string = prevString;

    char* prevEnd = end;
    while (end > string) {
        cp = utf8::unchecked::prior(end);
        if (!isUnicodeSpace(cp))
            break;
        prevEnd = end;
    }
    end = prevEnd;

    if (string == end) {
        // all spaces;
        return end;
    }

    *end = '\0';
    return string;
}

void ReadLine::handleReadLine(char* line)
{
    if (line && !*line)
        return;

    add_history(line);

    UVMutexLocker locker(*CallbackData::mutex);
    CallbackData data({ stripwhite(line) });
    sReadLine->async.data = &data;
    uv_async_send(&sReadLine->async);

    while (!CallbackData::done) {
        CallbackData::cond->wait(*CallbackData::mutex);
    }
    CallbackData::done = false;

    if (line)
        free(line);
}

void ReadLine::Run(uv_work_t *req)
{
    rl_callback_handler_install("hello: ", handleReadLine);

    const int p = sReadLine->rlPipe[0];
    fd_set rd;
    int e;
    int max = std::max(STDIN_FILENO, p);
    for (;;) {
        FD_ZERO(&rd);
        FD_SET(STDIN_FILENO, &rd);
        FD_SET(p, &rd);
        eintrwrap(e, ::select(max + 1, &rd, 0, 0, 0));
        if (e <= 0) {
            fprintf(stderr, "select failed %d %d\n", e, errno);
            fflush(stderr);
            abort();
        }
        if (FD_ISSET(STDIN_FILENO, &rd)) {
            rl_callback_read_char();
        }
        if (FD_ISSET(p, &rd)) {
            char c;
            eintrwrap(e, ::read(p, &c, 1));
            if (e < 0) {
                fprintf(stderr, "read failed %d\n", errno);
                fflush(stderr);
                abort();
            }
            if (!e || c == 'q')
                break;
        }
    }

    rl_callback_handler_remove();

    UVMutexLocker locker(*CallbackData::mutex);
    CallbackData::done = true;
    CallbackData::cond->broadcast();
}

void ReadLine::Done(uv_work_t *req, int /*status*/)
{
    uv_close(reinterpret_cast<uv_handle_t*>(&sReadLine->async), 0);
}

ReadLine::ReadLine()
    : ObjectWrap()
{
    assert(!sReadLine);
    sReadLine = this;

    std::call_once(isUtf8Flag, []() { setlocale(LC_ALL, ""); if (!strcmp(nl_langinfo(CODESET), "UTF-8")) isUtf8 = true; });

    CallbackData::mutex = new UVMutex;
    CallbackData::cond = new UVCondition;

    if (::pipe(rlPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }
    loop = uv_default_loop();
    uv_async_init(loop, &async, RunCallback);
    uv_queue_work(loop, &work, Run, Done);
}

ReadLine::~ReadLine()
{
    cleanup();
}

void ReadLine::handleLine(char* line)
{
    HandleScope scope;

    Handle<Value> str = line ? String::New(line) : Undefined();
    Handle<Context> ctx = Context::GetCurrent();
    callback->Call(ctx->Global(), 1, &str);
}

void ReadLine::cleanup()
{
    if (!sReadLine)
        return;

    UVMutexLocker locker(*CallbackData::mutex);

    int w;
    int fd = sReadLine->rlPipe[1];
    eintrwrap(w, ::write(fd, "q", 1));

    while (!CallbackData::done) {
        CallbackData::cond->wait(*CallbackData::mutex);
    }

    locker.unlock();
    CallbackData::done = false;
    delete CallbackData::mutex;
    CallbackData::mutex = 0;
    delete CallbackData::cond;
    CallbackData::cond = 0;

    sReadLine = 0;
}

Handle<Value> ReadLine::cleanup(const Arguments& args)
{
    HandleScope scope;

    ReadLine* obj = ObjectWrap::Unwrap<ReadLine>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("ReadLine.cleanup takes no arguments")));
    }
    obj->cleanup();

    return Undefined();
}

Handle<Value> ReadLine::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one callback argument")));
    }

    if (args[0].IsEmpty() || !args[0]->IsFunction()) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one callback argument")));
    }

    if (sReadLine) {
        return ThrowException(Exception::TypeError(String::New("Can only have one ReadLine object at a time")));
    }

    ReadLine* obj = new ReadLine;
    obj->callback = Persistent<v8::Function>::New(Handle<v8::Function>::Cast(args[0]));
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    ReadLine::init(target);
}

NODE_MODULE(ReadLine, RegisterModule);
