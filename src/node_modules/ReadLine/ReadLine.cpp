#include "ReadLine.h"
#include <stdlib.h>

class UVMutex
{
public:
    UVMutex()
    {
        uv_mutex_init(&mutex);
    }
    ~UVMutex()
    {
        uv_mutex_destroy(&mutex);
    }

    void lock()
    {
        uv_mutex_lock(&mutex);
    }
    void unlock()
    {
        uv_mutex_unlock(&mutex);
    }

private:
    uv_mutex_t mutex;

    friend class UVCondition;
};

class UVCondition
{
public:
    UVCondition()
    {
        uv_cond_init(&cond);
    }
    ~UVCondition()
    {
        uv_cond_destroy(&cond);
    }

    void wait(UVMutex& mutex)
    {
        uv_cond_wait(&cond, &mutex.mutex);
    }
    void signal()
    {
        uv_cond_signal(&cond);
    }
    void broadcast()
    {
        uv_cond_broadcast(&cond);
    }

private:
    uv_cond_t cond;
};

class UVMutexLocker
{
public:
    UVMutexLocker(UVMutex& mutex)
        : m(mutex)
    {
        m.lock();
    }
    ~UVMutexLocker()
    {
        m.unlock();
    }

private:
    UVMutex& m;
};

#define eintrwrap(VAR, BLOCK)                   \
    do {                                        \
        VAR = BLOCK;                            \
    } while (VAR == -1 && errno == EINTR)

using namespace v8;

Persistent<FunctionTemplate> ReadLine::constructor;

void ReadLine::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("ReadLine");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    target->Set(name, constructor->GetFunction());
}

struct CallbackData
{
    static UVMutex mutex;
    static UVCondition cond;

    ReadLine* rl;
    char* line;
    bool done;
};

UVMutex CallbackData::mutex;
UVCondition CallbackData::cond;

void ReadLine::RunCallback(uv_async_t* handle, int /*status*/)
{
    UVMutexLocker locker(CallbackData::mutex);
    CallbackData* data = static_cast<CallbackData*>(handle->data);
    char* line = data->line;

    data->rl->handleLine(line);

    free(line);

    data->done = true;
    CallbackData::cond.signal();
}

void ReadLine::Run(uv_work_t *req)
{
    ReadLine* rl = static_cast<ReadLine*>(req->data);
    for (;;) {
        char* line = readline("hello: ");
        if (true) {
            UVMutexLocker locker(CallbackData::mutex);
            CallbackData data({ rl, line, false });
            rl->async.data = &data;
            uv_async_send(&rl->async);

            while (!data.done) {
                CallbackData::cond.wait(CallbackData::mutex);
            }
        } else {
            free(line);
        }
    }
}

void ReadLine::Done(uv_work_t *req, int /*status*/)
{
    ReadLine* rl = static_cast<ReadLine*>(req->data);
    uv_close(reinterpret_cast<uv_handle_t*>(&rl->async), 0);
}

ReadLine::ReadLine()
    : ObjectWrap()
{
    loop = uv_default_loop();
    work.data = this;
    uv_async_init(loop, &async, RunCallback);
    uv_queue_work(loop, &work, Run, Done);
}

ReadLine::~ReadLine()
{
}

void ReadLine::handleLine(char* line)
{
    HandleScope scope;

    Handle<Value> str = line ? String::New(line) : Undefined();
    Handle<Context> ctx = Context::GetCurrent();
    callback->Call(ctx->Global(), 1, &str);
}

Handle<Value> ReadLine::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one callback argument")));
    }

    if (args[0].IsEmpty() || !args[0]->IsFunction()) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one callback argument")));
    }

    ReadLine* obj = new ReadLine;
    obj->callback = Persistent<v8::Function>::New(Handle<v8::Function>::Cast(args[0]));
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    ReadLine::init(target);
}

NODE_MODULE(ReadLine, RegisterModule);
