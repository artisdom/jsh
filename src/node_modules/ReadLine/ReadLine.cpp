#include "ReadLine.h"
#include "Util.h"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <langinfo.h>
#include <sys/types.h>
#include <algorithm>
#include <functional>
#include <utf8.h>
#include <mutex>
#include <readline/readline.h>
#include <readline/history.h>

//#define NO_STDOUTREPLACE

static std::once_flag isUtf8Flag;
static bool isUtf8 = false;

using namespace v8;

Persistent<FunctionTemplate> ReadLine::constructor;

void ReadLine::init(Handle<Object> target)
{
    HandleScope scope;

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("ReadLine");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    NODE_SET_PROTOTYPE_METHOD(constructor, "cleanup", cleanup);
    NODE_SET_PROTOTYPE_METHOD(constructor, "resume", resume);

    target->Set(name, constructor->GetFunction());
}

static UVMutex* mutex = 0;
static bool jsWaiting = false;
static bool completing = false;
static bool finDone = false;
static UVCondition* finCond = 0;
static UVCondition* compCond = 0;
static ReadLine* sReadLine = 0;

struct SendRequest
{
public:
    enum Type { Line, Complete };

    SendRequest(char* l)
        : type(Line), data(l), start(-1), end(-1), completion(0)
    {
    };
    SendRequest(char* t, const char* c, int s, int e)
        : type(Complete), data(t), comp(c), start(s), end(e), completion(0)
    {
    }

    const Type type;
    char* data;
    const char* comp;
    const int start, end;

    char** completion;
};

void ReadLine::RunCallback(uv_async_t* handle, int /*status*/)
{
    SendRequest* req;
    {
        UVMutexLocker locker(*mutex);
        req = static_cast<SendRequest*>(handle->data);
    }

    switch (req->type) {
    case SendRequest::Line:
        sReadLine->handleLine(req->data);
        delete req;
        break;
    case SendRequest::Complete: {
        char** c = sReadLine->handleComplete(req->data, req->comp, req->start, req->end);
        UVMutexLocker locker(*mutex);
        completing = false;
        req->completion = c;
        compCond->signal();
        break; }
    }
}

static inline bool isUnicodeSpace(uint32_t cp)
{
    switch (cp) {
    case 0x0009:
    case 0x000A:
    case 0x000B:
    case 0x000C:
    case 0x000D:
    case 0x0020:
    case 0x0085:
    case 0x00A0:
    case 0x1680:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200A:
    case 0x2028:
    case 0x2029:
    case 0x202F:
    case 0x205F:
    case 0x3000:
        return true;
    }
    return false;
}

char* stripwhite(char* string)
{
    if (!string || !isUtf8)
        return string;

    uint32_t cp;
    char* end = string + strlen(string);
    char* prevString = string;
    while (string < end) {
        cp = utf8::unchecked::next(string);
        if (!isUnicodeSpace(cp))
            break;
        prevString = string;
    }
    string = prevString;

    char* prevEnd = end;
    while (end > string) {
        cp = utf8::unchecked::prior(end);
        if (!isUnicodeSpace(cp))
            break;
        prevEnd = end;
    }
    end = prevEnd;

    if (string == end) {
        // all spaces;
        return end;
    }

    *end = '\0';
    return string;
}

void ReadLine::handleReadLine(char* line)
{
    if (line && !*line)
        return;

    if (line)
        add_history(line);

    UVMutexLocker locker(*mutex);
    sReadLine->async.data = new SendRequest(line);
    uv_async_send(&sReadLine->async);
    jsWaiting = true;

    rl_callback_handler_remove();
}

char** ReadLine::attemptShellCompletion(const char* text, int start, int end)
{
    rl_completion_suppress_append = 1;
    rl_attempted_completion_over = 1;

    UVMutexLocker locker(*mutex);
    SendRequest* req = new SendRequest(rl_line_buffer, text, start, end);
    completing = true;
    sReadLine->async.data = req;
    uv_async_send(&sReadLine->async);

    while (completing) {
        compCond->wait(*mutex);
    }

    char** c = req->completion;
    delete req;
    return c;
}

void ReadLine::Run(uv_work_t *req)
{
    // init readline
    rl_readline_name = "jsh";

    // initialize completion
    rl_attempted_completion_function = attemptShellCompletion;
    rl_completer_quote_characters = "'\"";

    rl_callback_handler_install("hello: ", handleReadLine);

    int max = 0;
    const int p = sReadLine->rlPipe[0];
    if (p > max)
        max = p;
    const int out = sReadLine->stdoutPipe[0];
    if (out > max)
        max = out;
    const int err = sReadLine->stderrPipe[0];
    if (err > max)
        max = err;

#ifndef NO_STDOUTREPLACE
    // take a copy of the real out and err
    const int oldout = ::dup(STDOUT_FILENO);
    const int olderr = ::dup(STDERR_FILENO);
    FILE* oldfout = fdopen(oldout, "w");
    FILE* oldferr = fdopen(olderr, "w");

    // replace stdout and stderr
    ::dup2(sReadLine->stdoutPipe[1], STDOUT_FILENO);
    ::dup2(sReadLine->stderrPipe[1], STDERR_FILENO);
#else
    FILE* oldferr = stderr;
    int oldout = -1, olderr = -1;
#endif

    enum { ReadSize = 16384 };
    char readbuf[ReadSize];

    fd_set rd;
    int e;
    for (;;) {
        FD_ZERO(&rd);
        {
            UVMutexLocker locker(*mutex);
            if (!jsWaiting) {
                FD_SET(STDIN_FILENO, &rd);
            }
        }
        FD_SET(p, &rd);
        FD_SET(out, &rd);
        FD_SET(err, &rd);
        eintrwrap(e, ::select(max + 1, &rd, 0, 0, 0));
        if (e <= 0) {
            fprintf(oldferr, "select failed %d %d\n", e, errno);
            fflush(oldferr);
            abort();
        }
        if (FD_ISSET(p, &rd)) {
            char c;
            eintrwrap(e, ::read(p, &c, 1));
            if (e < 0) {
                fprintf(oldferr, "read failed %d\n", errno);
                fflush(oldferr);
                abort();
            }
            if (!e || c == 'q')
                break;
            rl_callback_handler_install("hello: ", handleReadLine);
        }
        if (FD_ISSET(out, &rd)) {
            // read data and write to oldout
            eintrwrap(e, ::read(out, readbuf, sizeof(readbuf)));
            if (e <= 0) {
                fprintf(oldferr, "read from stdout failed %d (%d)\n", e, errno);
                fflush(oldferr);
                abort();
            }
            int p = 0;
            const int r = e;
            do {
                eintrwrap(e, ::write(oldout, readbuf + p, r - p));
                if (e < 0) {
                    fprintf(oldferr, "write to stdout failed %d (%d)\n", e, errno);
                    fflush(oldferr);
                    abort();
                }
                p += e;
            } while (p < r);
        }
        if (FD_ISSET(err, &rd)) {
            // read data and write to olderr
            eintrwrap(e, ::read(err, readbuf, sizeof(readbuf)));
            if (e <= 0) {
                fprintf(oldferr, "read from stderr failed %d (%d)\n", e, errno);
                fflush(oldferr);
                abort();
            }
            int p = 0;
            const int w = e;
            do {
                eintrwrap(e, ::write(olderr, readbuf + p, w - p));
                if (e < 0) {
                    fprintf(oldferr, "write to stderr failed %d (%d)\n", e, errno);
                    fflush(oldferr);
                    abort();
                }
                p += e;
            } while (p < w);
        }
        if (FD_ISSET(STDIN_FILENO, &rd)) {
            rl_callback_read_char();
        }
    }

    rl_callback_handler_remove();

    // reset stdout and stderr back to normal

#ifndef NO_STDOUTREPLACE
    fclose(oldfout);
    fclose(oldferr);
    ::dup2(oldout, STDOUT_FILENO);
    ::dup2(olderr, STDERR_FILENO);
    ::close(oldout);
    ::close(olderr);
#endif

    UVMutexLocker locker(*mutex);
    finDone = true;
    finCond->broadcast();
}

void ReadLine::Done(uv_work_t *req, int /*status*/)
{
    uv_close(reinterpret_cast<uv_handle_t*>(&sReadLine->async), 0);
}

ReadLine::ReadLine()
    : ObjectWrap()
{
    assert(!sReadLine);
    sReadLine = this;

    std::call_once(isUtf8Flag, []() { setlocale(LC_ALL, ""); if (!strcmp(nl_langinfo(CODESET), "UTF-8")) isUtf8 = true; });

    mutex = new UVMutex;
    finCond = new UVCondition;
    compCond = new UVCondition;
    jsWaiting = finDone = completing = false;

    if (::pipe(rlPipe) || ::pipe(stdoutPipe) || ::pipe(stderrPipe)) {
        fprintf(stderr, "Unable to create pipe\n");
        fflush(stderr);
        abort();
    }
    loop = uv_default_loop();
    uv_async_init(loop, &async, RunCallback);
    uv_queue_work(loop, &work, Run, Done);
}

ReadLine::~ReadLine()
{
    cleanup();
}

char** ReadLine::handleComplete(char* text, const char* comp, int start, int end)
{
    HandleScope scope;

    Handle<Object> obj = Object::New();
    obj->Set(String::New("text"), String::New(text));
    obj->Set(String::New("comp"), String::New(comp));
    obj->Set(String::New("start"), Integer::New(start));
    obj->Set(String::New("end"), Integer::New(end));

    Handle<Value> val = obj;

    Handle<Context> ctx = Context::GetCurrent();
    Handle<Value> ret = completeCallback->Call(ctx->Global(), 1, &val);
    if (ret.IsEmpty() || ret->IsUndefined())
        return 0;
    if (ret->IsString() || ret->IsNumber()) {
        // just one result, generate an array out of it
        String::Utf8Value str(ret);
        char** arr = static_cast<char**>(malloc(2 * sizeof(char*)));
#warning verify that this strdup and the one below wont leak
        arr[0] = strdup(*str);
        arr[1] = 0;
        return arr;
    } else if (ret->IsArray()) {
        Handle<Array> list = Handle<Array>::Cast(ret);
        int count = 0;
        const int len = list->Length();
        // assume the complete array will be the length of the js array for now
        char** arr = static_cast<char**>(malloc((len + 1) * sizeof(char*)));
        for (int i = 0; i < len; ++i) {
            Handle<Value> val = list->Get(i);
            if (val.IsEmpty() || (!val->IsString() && !val->IsNumber()))
                continue;
            String::Utf8Value str(val);
            arr[count] = strdup(*str);
            ++count;
        }
        arr[count] = 0;
        return arr;
    }
    return 0;
}

void ReadLine::handleLine(char* line)
{
    HandleScope scope;

    Handle<Value> str = line ? String::New(stripwhite(line)) : Undefined();
    Handle<Context> ctx = Context::GetCurrent();
    lineCallback->Call(ctx->Global(), 1, &str);

    if (line)
        free(line);
}

void ReadLine::wakeup(char c)
{
    int w;
    eintrwrap(w, ::write(rlPipe[1], &c, 1));
}

void ReadLine::quit()
{
    wakeup('q');
}

void ReadLine::cleanup()
{
    if (!sReadLine)
        return;

    quit();

    UVMutexLocker locker(*mutex);
    while (!finDone) {
        finCond->wait(*mutex);
    }

    ::close(rlPipe[0]);
    ::close(rlPipe[1]);
    ::close(stdoutPipe[0]);
    ::close(stdoutPipe[1]);
    ::close(stderrPipe[0]);
    ::close(stderrPipe[1]);

    locker.unlock();
    delete mutex;
    delete finCond;
    delete compCond;

    sReadLine = 0;
}

Handle<Value> ReadLine::cleanup(const Arguments& args)
{
    HandleScope scope;

    ReadLine* obj = ObjectWrap::Unwrap<ReadLine>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("ReadLine.cleanup takes no arguments")));
    }
    obj->cleanup();

    return Undefined();
}

Handle<Value> ReadLine::resume(const Arguments& args)
{
    HandleScope scope;

    ReadLine* obj = ObjectWrap::Unwrap<ReadLine>(args.This());
    if (args.Length() > 0) {
        return ThrowException(Exception::TypeError(String::New("ReadLine.resume takes no arguments")));
    }

    UVMutexLocker locker(*mutex);
    jsWaiting = false;
    obj->wakeup();

    return Undefined();
}

Handle<Value> ReadLine::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 2) {
        return ThrowException(Exception::TypeError(String::New("ReadLine takes one line callback and one complete callback argument")));
    }

    if (args[0].IsEmpty() || !args[0]->IsFunction()) {
        return ThrowException(Exception::TypeError(String::New("ReadLine needs a line callback argument")));
    }

    if (args[1].IsEmpty() || !args[1]->IsFunction()) {
        return ThrowException(Exception::TypeError(String::New("ReadLine needs a complete callback argument")));
    }

    if (sReadLine) {
        return ThrowException(Exception::TypeError(String::New("Can only have one ReadLine object at a time")));
    }

    ReadLine* obj = new ReadLine;
    obj->lineCallback = Persistent<v8::Function>::New(Handle<v8::Function>::Cast(args[0]));
    obj->completeCallback = Persistent<v8::Function>::New(Handle<v8::Function>::Cast(args[1]));
    obj->Wrap(args.This());

    return args.This();
}

void RegisterModule(Handle<Object> target)
{
    ReadLine::init(target);
}

NODE_MODULE(ReadLine, RegisterModule);
