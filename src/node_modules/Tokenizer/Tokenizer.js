var glob = require('glob');

var NORMAL = 0;
var QUOTE = 1;
var SINGLEQUOTE = 2;
var BRACE = 3;
var PAREN = 4;
var DOLLAR = 5;

var SCRIPT = 0x1;
var SHELL = 0x2;
var TOLERANT = 0x4;

var HIDDEN = 0;
var OPERATOR = 1;
var COMMAND = 2;
var QUOTEDCOMMAND = 3;
var JAVASCRIPT = 4;
var GROUP = 5;
var VARIABLE = 6;

function stateToType(state)
{
    switch (state) {
    case QUOTE:
    case SINGLEQUOTE:
        return QUOTEDCOMMAND;
    case BRACE:
        return JAVASCRIPT;
    case PAREN:
        return GROUP;
    case DOLLAR:
        return VARIABLE;
    }
    return COMMAND;
};

function stripEscapes(str)
{
    var ret = str;
    var off = 0;
    for (var idx = 0; idx < str.length; ++idx) {
        if (str[idx] === '\\') {
            var rem = ret.substr(idx + 1 - off);
            ret = ret.substr(0, idx - off++) + rem;
            if ((idx + 1 < str.length && str[idx + 1] === '\\'))
                ++idx;
        }
    }
    return ret;
}

function expandTilde(str)
{
    var idx = str.indexOf('~');
    if (idx === -1)
        return str;
    var end = str.indexOf('/', idx + 1);
    if (end === -1)
        end = str.length;

    var home;

    if (idx + 1 === end) {
        home = process.env.HOME;
    } else {
        var user = str.substring(idx + 1, end);
        var res = new RegExp("^/[^/]+\/").exec(process.env.HOME);
        if (!res)
            throw "Can't parse home: " + process.env.HOME;
        home = res[0] + user;
    }
    return str.substr(0, idx) + home + str.substr(end);
}

function Tokenizer(flags)
{
    this._flags = flags;
    this._line = undefined;
    this._pos = undefined;
    this._prev = undefined;
    this._state.state = [];
}

Tokenizer.prototype._state = {
    state: [],
    push: function(s) { this.state.push(s); },
    pop: function() { return this.state.length > 1 ? this.state.pop() : undefined; },
    value: function() {
        if (this.state.length === 0)
            throw("state length is 0");
        return this.state[this.state.length - 1];
    },
    prev: function() {
        if (this.state.length === 0)
            throw("state length is 0");
        if (this.state.length === 1)
            return undefined;
        return this.state[this.state.length - 2];
    },
    count: function(s) {
        if (this.state.length === 0)
            throw("state length is 0");
        var pos = this.state.length - 1;
        var cnt = 0;
        while (pos >= 0) {
            if (this.state[pos] !== s)
                return cnt;
            --pos;
            ++cnt;
        }
        return cnt;
    },
    is: function() {
        for (var i in arguments) {
            if (this.value() === arguments[i])
                return true;
        }
        return false;
    }
};

Tokenizer.prototype.tokenize = function(line)
{
    this._line = line;
    this._pos = this._prev = 0;
    this._state.push(NORMAL);
};

Tokenizer.prototype._addPrev = function(type, entry, force)
{
    if (force || this._pos > this._prev) {
        var data = stripEscapes(this._line.substr(this._prev, this._pos - this._prev));
        if (this._flags & SHELL) {
            if (type === COMMAND) {
                var old = data;
                data = expandTilde(data);
            } else if (type === QUOTEDCOMMAND) {
                type = COMMAND;
            }
        }
        entry.push({ type: type, data: data, from: this._prev, to: this._pos });
    }
    this._prev = this._pos + 1;
};

Tokenizer.prototype._addOperator = function(entry)
{
    var op = this._line[this._pos];
    var len = 1;
    if (this._pos + 1 < this._line.length && this._line[this._pos + 1] === op) {
        len = 2;
    }
    entry.push({ type: OPERATOR, data: stripEscapes(this._line.substr(this._pos, len)), from: this._pos, to: this._pos + len });
    if (len === 2)
        ++this._pos;
    this._prev = this._pos + 1;
    return len;
};

Tokenizer.prototype._addHidden = function(entry, data)
{
    entry.push({ type: HIDDEN, data: data });
};

Tokenizer.prototype._glob = function(entry)
{
    // find the end point
    var escape = false, idx;
    var endCandidates = " '\"({;|&<=>,";
    for (idx = this._pos; idx < this._line.length; ++idx) {
        if (this._line[idx] === '\\') {
            escape = !escape;
        } else if (escape) {
            escape = false;
        } else if (endCandidates.indexOf(this._line[idx]) !== -1) {
            break;
        }
    }
    var str = stripEscapes(this._line.substring(this._prev, idx));
    var result = glob.sync(str);
    jsh.log("globbing '" + str + "' => " + JSON.stringify(result));
    if (result.length === 0) {
        return;
    }
    this._prev = idx;
    this._pos = idx - 1;

    for (idx = 0; idx < result.length; ++idx)
        entry.push({ type: COMMAND, data: result[idx] });
};

Tokenizer.prototype._maybeAddVariable = function(entry)
{
    if (this._state.value() === DOLLAR) {
        this._addPrev(VARIABLE, entry);
        this._state.pop();
        if (this._state.value() === PAREN
            || this._state.value() === BRACE) {
            --this._prev;
        }
    }
};

Tokenizer.prototype.next = function()
{
    var entry = [], len, ch, st;

    var expandVariables = typeof jsh === "object" && typeof jsh.config === "object" && jsh.config.expandVariables;

    var done = false;
    this._prev = this._pos;
    var start = this._prev;
    var varStart;
    var escape = false;

    var that = this;

    function addOperator()
    {
        that._addPrev(COMMAND, entry);
        that._addOperator(entry);
    }
    while (!done && this._pos < this._line.length) {
        ch = this._line[this._pos];
        switch (ch) {
        case '"':
            if (!escape)
                this._maybeAddVariable(entry);
            if (this._state.is(NORMAL)
                || (escape && this._state.is(QUOTE))) {
                if (!escape) {
                    this._addPrev(QUOTEDCOMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.push(QUOTE);
                } else {
                    escape = false;
                }
            } else if (this._state.is(QUOTE)) {
                if (!escape) {
                    this._addPrev(QUOTEDCOMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.pop();
                } else {
                    escape = false;
                }
            }
            break;
        case '\'':
            if (this._state.is(NORMAL)
                || (escape && this._state.is(SINGLEQUOTE))) {
                if (!escape) {
                    this._addPrev(QUOTEDCOMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.push(SINGLEQUOTE);
                } else {
                    escape = false;
                }
            } else if (this._state.is(SINGLEQUOTE)) {
                if (!escape) {
                    this._addPrev(QUOTEDCOMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.pop();
                } else {
                    escape = false;
                }
            }
            break;
        case '{':
        case '(':
            if (!escape)
                this._maybeAddVariable(entry);
            st = (ch === '{' ? BRACE : PAREN);
            if (escape && this._state.is(NORMAL)) {
                escape = false;
            } else if (this._flags & SHELL) {
                if (this._state.is(NORMAL, st)) {
                    if (this._state.is(NORMAL)) {
                        this._addPrev(COMMAND, entry);
                        if (entry.length !== 0)
                            return entry;
                    }
                }
                this._state.push(st);
            } else {
                addOperator();
            }
            break;
        case '}':
        case ')':
            if (!escape)
                this._maybeAddVariable(entry);
            st = (ch === '}' ? BRACE : PAREN);
            if (escape && this._state.is(NORMAL)) {
                escape = false;
            } else if (this._flags & SHELL) {
                if (this._state.is(st)) {
                    if (this._state.prev() === NORMAL) {
                        this._addPrev((st === BRACE) ? JAVASCRIPT : GROUP, entry, true);
                    }
                }
                this._state.pop();
            } else {
                addOperator();
            }
            break;
        case ';':
            if (!escape)
                this._maybeAddVariable(entry);
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    if (this._flags & SHELL) {
                        this._addPrev(COMMAND, entry);
                        this._addHidden(entry, ';');
                    } else {
                        addOperator();
                    }
                    done = true;
                } else {
                    escape = false;
                }
            }
            break;
        case ' ':
            if (!escape) {
                this._maybeAddVariable(entry);
                if (this._state.is(NORMAL)) {
                    this._addPrev(COMMAND, entry);
                }
            } else {
                escape = false;
            }
            break;
        case '|':
            if (!escape)
                this._maybeAddVariable(entry);
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    addOperator();
                    if (this._flags & SHELL)
                        done = true;
                } else {
                    escape = false;
                }
            }
            break;
        case '&':
            if (!escape)
                this._maybeAddVariable(entry);
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    addOperator();
                    if (this._flags & SHELL)
                        done = true;
                } else {
                    escape = false;
                }
            }
            break;
        case '>':
        case '<':
        case '=':
        case ',':
            if (!escape)
                this._maybeAddVariable(entry);
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    addOperator();
                } else {
                    escape = false;
                }
            }
            break;
        case '*':
        case '?':
        case '[':
            if (!escape)
                this._maybeAddVariable(entry);
            if (this._state.is(NORMAL)) {
                if (escape) {
                    escape = false;
                } else if (this._flags & SHELL) {
                    this._glob(entry);
                } else {
                    addOperator();
                }
            }
            break;
        case '\\':
            if (this._state.is(NORMAL, QUOTE, BRACE, PAREN)) {
                escape = !escape;
            }
            break;
        case '$':
            if (!escape)
                this._maybeAddVariable(entry);
            if (expandVariables && !escape && !this._state.is(SINGLEQUOTE)) {
                this._addPrev(stateToType(this._state.value()), entry);
                this._state.push(DOLLAR);
            } else if (escape) {
                escape = false;
            }
            break;
        default:
            if (escape)
                escape = false;
            if (this._flags & SCRIPT && !/[0-9a-zA-Z_$]/.exec(ch)) {
                addOperator();
            }
            break;
        }
        ++this._pos;
    }

    this._maybeAddVariable(entry);

    if (!(this._flags & TOLERANT) && !this._state.is(NORMAL)) {
        throw "Tokenizer didn't end in normal state";
    }

    this._addPrev(COMMAND, entry);
    if (entry.length > 0) {
        var e = entry[entry.length - 1];
        if (this._flags & SHELL && e.type !== OPERATOR && e.data !== ";")
            entry.push({ type: HIDDEN, data: ";" });
    }

    return entry.length === 0 ? undefined : entry;
};

module.exports = {
    Tokenizer: Tokenizer,

    expandTilde: expandTilde,
    stripEscapes: stripEscapes,

    JAVASCRIPT: JAVASCRIPT,
    SHELL: SHELL,

    NORMAL: NORMAL,
    QUOTE: QUOTE,
    SINGLEQUOTE: SINGLEQUOTE,
    BRACE: BRACE,
    PAREN: PAREN,

    HIDDEN: HIDDEN,
    OPERATOR: OPERATOR,
    COMMAND: COMMAND,
    QUOTEDCOMMAND: QUOTEDCOMMAND,
    JAVASCRIPT: JAVASCRIPT,
    GROUP: GROUP,
    VARIABLE: VARIABLE,

    SHELL: SHELL,
    SCRIPT: SCRIPT,
    TOLERANT: TOLERANT
};
