var glob = require('glob');

var NORMAL = 0;
var QUOTE = 1;
var SINGLEQUOTE = 2;
var BRACE = 3;
var PAREN = 4;
var VARIABLE = 5;

var HIDDEN = 0;
var OPERATOR = 1;
var COMMAND = 2;
var JAVASCRIPT = 3;
var GROUP = 4;
var NOGLOBMATCH = 5;

function stripEscapes(str)
{
    var ret = str;
    var off = 0;
    for (var idx = 0; idx < str.length; ++idx) {
        if (str[idx] === '\\') {
            var rem = ret.substr(idx + 1 - off);
            ret = ret.substr(0, idx - off++) + rem;
            if ((idx + 1 < str.length && str[idx + 1] === '\\'))
                ++idx;
        }
    }
    return ret;
}

function Tokenizer()
{
    this._line = undefined;
    this._pos = undefined;
    this._prev = undefined;
    this._replaced = false;
    this._state.state = [];
}

Tokenizer.prototype._state = {
    state: [],
    push: function(s) { this.state.push(s); },
    pop: function() { return this.state.pop(); },
    value: function() {
        if (this.state.length === 0)
            throw("state length is 0");
        return this.state[this.state.length - 1];
    },
    prev: function() {
        if (this.state.length === 0)
            throw("state length is 0");
        if (this.state.length === 1)
            return undefined;
        return this.state[this.state.length - 2];
    },
    count: function(s) {
        if (this.state.length === 0)
            throw("state length is 0");
        var pos = this.state.length - 1;
        var cnt = 0;
        while (pos >= 0) {
            if (this.state[pos] !== s)
                return cnt;
            --pos;
            ++cnt;
        }
        return cnt;
    },
    is: function() {
        for (var i in arguments) {
            if (this.value() === arguments[i])
                return true;
        }
        return false;
    }
};

Tokenizer.prototype.tokenize = function(line)
{
    this._line = line;
    this._pos = this._prev = 0;
    this._state.push(NORMAL);
};

Tokenizer.prototype._addPrev = function(type, entry, force)
{
    if (force || this._pos > this._prev)
        entry.push({ type: type, data: stripEscapes(this._line.substr(this._prev, this._pos - this._prev)), from: this._prev, to: this._pos });
    this._prev = this._pos + 1;
};

Tokenizer.prototype._addOperator = function(entry)
{
    var op = this._line[this._pos];
    var len = 1;
    if (this._pos + 1 < this._line.length && this._line[this._pos + 1] === op) {
        len = 2;
    }
    entry.push({ type: OPERATOR, data: stripEscapes(this._line.substr(this._pos, len)), from: this._pos, to: this._pos + len });
    if (len === 2)
        ++this._pos;
    this._prev = this._pos + 1;
    return len;
};

Tokenizer.prototype._addHidden = function(entry, data)
{
    entry.push({ type: HIDDEN, data: data });
};

Tokenizer.prototype._glob = function(entry)
{
    // find the end point
    var escape = false, idx;
    var endCandidates = " '\"({;|&<=>,";
    for (idx = this._pos; idx < this._line.length; ++idx) {
        if (this._line[idx] === '\\') {
            escape = !escape;
        } else if (!escape && endCandidates.indexOf(this._line[idx]) !== -1) {
            break;
        }
    }
    var str = this._line.substring(this._prev, idx);
    var result = glob.sync(str);
    jsh.log("globbing '" + str + "' => " + JSON.stringify(result));
    this._prev = idx;
    this._pos = idx - 1;

    if (result.length === 0) {
        console.log("jsh: no matches found: " + str);
        entry.push({ type: NOGLOBMATCH });
    } else {
        for (idx = 0; idx < result.length; ++idx)
            entry.push({ type: COMMAND, data: result[idx] });
    }
};

Tokenizer.prototype._replaceVariable = function(variableStart)
{
    var variable = this._line.substring(variableStart + 1, this._pos);

    var list = variable.split('.');
    var obj = global;
    for (var i in list) {
        if (obj === undefined)
            break;
        obj = obj[list[i]];
    }
    var val = "" + obj;

    var rem = this._line.substr(this._pos);
    this._line = this._line.substr(0, variableStart) + val + rem;

    // update this._pos to be where the end was
    this._pos += val.length - variable.length - 1;

    var ch = this._line[this._pos];
    jsh.log("after '" + this._line + "' - '" + ch + "' diff " + (val.length - variable.length));
};

Tokenizer.prototype.replaceVariables = function()
{
    var expandVariables = !this._replaced && (typeof jsh === "object" && typeof jsh.config === "object" && jsh.config.expandVariables);

    if (!expandVariables) {
        return stripEscapes(this._line);
    }
    this._replaced = true;

    // simply find variables inside of quites
    var ch, varStart;
    var escape = false;
    this._pos = this._prev = 0;
    while (this._pos < this._line.length) {
        ch = this._line[this._pos];
        switch (ch) {
        case '"':
            if (escape) {
                escape = false;
            } else {
                if (this._state.is(NORMAL)) {
                    this.state.push(QUOTE);
                } else if (this._state.is(QUOTE, VARIABLE)) {
                    if (this._state.is(VARIABLE)) {
                        this._replaceVariable(varStart);
                        this._state.pop();
                    }
                    this.state._pop();
                }
            }
            break;
        case '\'':
            if (escape) {
                escape = false;
            } else {
                if (this._state.is(NORMAL)) {
                    this._state.push(SINGLEQUOTE);
                } else if (this._state.is(SINGLEQUOTE)) {
                    this._state.pop();
                }
            }
            break;
        case '$':
            if (escape) {
                escape = false;
            } else {
                if (this._state.is(QUOTE)) {
                    this._state.push(VARIABLE);
                    varStart = this._pos;
                }
            }
            break;
        case ' ':
            if (escape) {
                escape = false;
            } else {
                if (this._state.is(VARIABLE)) {
                    this._replaceVariable(varStart);
                    this._state.pop();
                }
            }
            break;
        case '\\':
            escape = !escape;
            break;
        default:
            if (escape)
                escape = false;
            break;
        }
        ++this._pos;
    }

    if (!this._state.is(NORMAL)) {
        throw "Tokenizer (replaceVariables) didn't end in normal state";
    }

    return stripEscapes(this._line);
};

Tokenizer.prototype.next = function()
{
    var entry = [], len, ch, st;

    var expandVariables = !this._replaced && (typeof jsh === "object" && typeof jsh.config === "object" && jsh.config.expandVariables);
    if (expandVariables)
        this._replaced = true;

    var done = false;
    this._prev = this._pos;
    var start = this._prev;
    var varStart;
    var escape = false;
    while (!done && this._pos < this._line.length) {
        ch = this._line[this._pos];
        switch (ch) {
        case '"':
            if (this._state.is(NORMAL)
                || (escape && this._state.is(QUOTE))) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.push(QUOTE);
                } else {
                    escape = false;
                }
            } else if (this._state.is(QUOTE, VARIABLE)) {
                if (!escape) {
                    if (this._state.is(VARIABLE)) {
                        this._replaceVariable(varStart);
                        this._state.pop();
                    }
                    this._addPrev(COMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.pop();
                } else {
                    escape = false;
                }
            }
            break;
        case '\'':
            if (this._state.is(NORMAL)
                || (escape && this._state.is(SINGLEQUOTE))) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.push(SINGLEQUOTE);
                } else {
                    escape = false;
                }
            } else if (this._state.is(SINGLEQUOTE)) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addHidden(entry, "'");
                    this._state.pop();
                } else {
                    escape = false;
                }
            }
            break;
        case '{':
        case '(':
            st = (ch === '{' ? BRACE : PAREN);
            if (escape && this._state.is(NORMAL)) {
                escape = false;
            } else if (this._state.is(NORMAL, st)) {
                if (this._state.is(NORMAL)) {
                    this._addPrev(COMMAND, entry);
                    if (entry.length !== 0)
                        return entry;
                }
                this._state.push(st);
            }
            break;
        case '}':
        case ')':
            st = (ch === '}' ? BRACE : PAREN);
            if (escape && this._state.is(NORMAL)) {
                escape = false;
            } else if (this._state.is(st)) {
                if (this._state.prev() === NORMAL) {
                    this._addPrev((st === BRACE) ? JAVASCRIPT : GROUP, entry, true);
                }
                this._state.pop();
            }
            break;
        case ';':
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addHidden(entry, ';');
                    done = true;
                } else {
                    escape = false;
                }
            }
            break;
        case ' ':
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                } else {
                    escape = false;
                }
            } else if (this._state.is(VARIABLE)) {
                this._replaceVariable(varStart);
                this._state.pop();
            }
            break;
        case '|':
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addOperator(entry);
                    done = true;
                } else {
                    escape = false;
                }
            }
            break;
        case '&':
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addOperator(entry);
                    done = true;
                } else {
                    escape = false;
                }
            }
            break;
        case '>':
        case '<':
        case '=':
        case ',':
            if (this._state.is(NORMAL)) {
                if (!escape) {
                    this._addPrev(COMMAND, entry);
                    this._addOperator(entry);
                } else {
                    escape = false;
                }
            }
            break;
        case "*":
        case "?":
        case "[":
            if (this._state.is(NORMAL)) {
                if (escape) {
                    escape = false;
                } else {
                    this._glob(entry);
                }
            }
            break;
        case '\\':
            if (this._state.is(NORMAL, QUOTE, SINGLEQUOTE)) {
                escape = !escape;
            }
            break;
        case '$':
            if (expandVariables && !escape && this._state.is(QUOTE)) {
                this._state.push(VARIABLE);
                varStart = this._pos;
            } else if (escape) {
                escape = false;
            }
            break;
        default:
            if (escape)
                escape = false;
            break;
        }
        ++this._pos;
    }

    if (!this._state.is(NORMAL)) {
        throw "Tokenizer didn't end in normal state";
    }

    this._addPrev(COMMAND, entry);
    if (entry.length > 0) {
        var e = entry[entry.length - 1];
        if (e.type !== OPERATOR && e.data !== ";")
            entry.push({ type: HIDDEN, data: ";" });
    }

    return entry.length === 0 ? undefined : entry;
};

module.exports = {
    Tokenizer: Tokenizer,

    NORMAL: NORMAL,
    QUOTE: QUOTE,
    SINGLEQUOTE: SINGLEQUOTE,
    BRACE: BRACE,
    PAREN: PAREN,

    HIDDEN: HIDDEN,
    OPERATOR: OPERATOR,
    COMMAND: COMMAND,
    JAVASCRIPT: JAVASCRIPT,
    GROUP: GROUP,
    NOGLOBMATCH: NOGLOBMATCH
};
