#ifndef UTIL_H
#define UTIL_H

#include <node.h>

class UVMutex
{
public:
    UVMutex()
    {
        uv_mutex_init(&mutex);
    }
    ~UVMutex()
    {
        uv_mutex_destroy(&mutex);
    }

    void lock()
    {
        uv_mutex_lock(&mutex);
    }
    void unlock()
    {
        uv_mutex_unlock(&mutex);
    }

private:
    uv_mutex_t mutex;

    friend class UVCondition;
};

class UVCondition
{
public:
    UVCondition()
    {
        uv_cond_init(&cond);
    }
    ~UVCondition()
    {
        uv_cond_destroy(&cond);
    }

    void wait(UVMutex& mutex)
    {
        uv_cond_wait(&cond, &mutex.mutex);
    }
    void signal()
    {
        uv_cond_signal(&cond);
    }
    void broadcast()
    {
        uv_cond_broadcast(&cond);
    }

private:
    uv_cond_t cond;
};

class UVMutexLocker
{
public:
    UVMutexLocker(UVMutex& mutex)
        : m(mutex), locked(true)
    {
        m.lock();
    }
    ~UVMutexLocker()
    {
        if (locked)
            m.unlock();
    }

    void unlock()
    {
        if (locked) {
            m.unlock();
            locked = false;
        }
    }

private:
    UVMutex& m;
    bool locked;
};

class UVThread
{
public:
    UVThread()
        : created(false)
    {
    }
    virtual ~UVThread()
    {
        join();
    }

    void start()
    {
        if (created)
            return;
        if (!uv_thread_create(&thr, staticStart, this))
            created = true;
    }

    void join()
    {
        if (!created)
            return;
        uv_thread_join(&thr);
        created = false;
    }

protected:
    virtual void run() = 0;

private:
    static void staticStart(void* arg)
    {
        UVThread* thr = static_cast<UVThread*>(arg);
        thr->run();
    }

private:
    uv_thread_t thr;
    bool created;
};

#define eintrwrap(VAR, BLOCK)                   \
    do {                                        \
        VAR = BLOCK;                            \
    } while (VAR == -1 && errno == EINTR)

#endif
