#ifndef PROCESSCHAIN_HPP
#define PROCESSCHAIN_HPP

#include <node.h>
#include <string>
#include <vector>
#include <map>
#include <cstdio>
#include <termios.h>

class ProcessChain : public node::ObjectWrap
{
public:
    static void init(v8::Handle<v8::Object> target);

    struct Entry {
        std::string program, cwd;
        std::vector<std::string> arguments, environment;
    };

private:
    ProcessChain();
    ~ProcessChain();

    enum Type { Foreground, Background };
    bool launch();

private:
    void notifyChild(pid_t pid, int status);
    void notifyRead(const char* str);
    void notifyStopped();

private:
    enum Status { Running, Stopped, Terminated };

    static v8::Handle<v8::Value> New(const v8::Arguments& args);
    static v8::Handle<v8::Value> chain(const v8::Arguments& args);
    static v8::Handle<v8::Value> write(const v8::Arguments& args);
    static v8::Handle<v8::Value> exec(const v8::Arguments& args);
    static v8::Handle<v8::Value> cont(const v8::Arguments& args);

    static v8::Persistent<v8::FunctionTemplate> constructor;
    v8::Persistent<v8::Function> mCallback;

    struct PidEntry {
        PidEntry() : status(Running), code(0) { }
        PidEntry(int code);

        Status status;
        int code;
    };

    struct DataEntry {
        enum { Child, Stdout } type;
        Status status;
        std::string data;
    };

    std::vector<Entry> mEntries;
    int mFinalPipe[2], mInPipe[2];
    std::map<pid_t, PidEntry> mPids;
    bool mLaunched;

    std::vector<DataEntry> mDatas;

    bool mInteractive;
    int32_t mShellPgid, mPgid;
    termios* mShellTermios;
    termios mTermios;
    Type mType;
    Status mStatus;
    bool mStdoutClosed;

private:
    friend class ReadThread;
    friend class WaitThread;
};

#endif
