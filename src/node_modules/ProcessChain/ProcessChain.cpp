#include "ProcessChain.h"
#include <Util.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <assert.h>
#include <algorithm>
#include <mutex>
#include <set>
#include <map>

#define eintrwrap(VAR, BLOCK)                   \
    do {                                        \
        VAR = BLOCK;                            \
    } while (VAR == -1 && errno == EINTR)

using namespace v8;

class ReadThread
{
public:
    ReadThread(uv_loop_t* loop);
    ~ReadThread();

    void addFd(int fd, ProcessChain* chain);
    void stop();

private:
    static void run(uv_work_t* work);
    static void done(uv_work_t* work, int status);
    static void asyncCall(uv_async_t* handle, int status);

    void run();

private:
    std::map<int, ProcessChain*> fds;
    int wakeup[2];

    struct AsyncData
    {
        const char* str;
        ProcessChain* chain;
    };

    static UVMutex mtx;
    static UVCondition cond;
    static bool finished;
    static uv_async_t async;
    static uv_work_t work;
};

UVMutex ReadThread::mtx;
UVCondition ReadThread::cond;
bool ReadThread::finished;
uv_async_t ReadThread::async;
uv_work_t ReadThread::work;

ReadThread::ReadThread(uv_loop_t* loop)
{
    if (::pipe(wakeup)) {
        fprintf(stderr, "pipe failed\n");
        fflush(stderr);
        abort();
    }

    work.data = this;
    uv_queue_work(loop, &work, run, done);
    uv_async_init(loop, &async, asyncCall);
}

ReadThread::~ReadThread()
{
    ::close(wakeup[0]);
    ::close(wakeup[1]);
}

void ReadThread::stop()
{
    char c = 'q';
    int w;
    eintrwrap(w, ::write(wakeup[1], &c, 1));
}

void ReadThread::addFd(int fd, ProcessChain* chain)
{
    UVMutexLocker locker(mtx);
    fds[fd] = chain;
    char c = 'w';
    int w;
    eintrwrap(w, ::write(wakeup[1], &c, 1));
}

void ReadThread::run(uv_work_t* work)
{
    ReadThread* thr = 0;
    {
        UVMutexLocker locker(mtx);
        thr = static_cast<ReadThread*>(work->data);
    }
    thr->run();
}

void ReadThread::run()
{
    fd_set rd;
    int max;
    std::map<int, ProcessChain*> local;
    for (;;) {
        FD_ZERO(&rd);
        {
            UVMutexLocker locker(mtx);
            local = fds;
        }
        max = wakeup[0];
        FD_SET(wakeup[0], &rd);
        for (auto fd : local) {
            // printf("selecting on %d\n", fd.first);
            FD_SET(fd.first, &rd);
            max = std::max(fd.first, max);
        }
        int s;
        eintrwrap(s, ::select(max + 1, &rd, 0, 0, 0));
        if (s <= 0) {
            fprintf(stderr, "ReadThread select failed %d %d\n", s, errno);
            fflush(stderr);
            abort();
        }
        for (auto fd : local) {
            if (FD_ISSET(fd.first, &rd)) {
                char buf[8192];
                eintrwrap(s, ::read(fd.first, buf, sizeof(buf) - 1));
                // printf("read %d (%d) from %d\n", s, errno, fd.first);
                if (s < 0) {
                    if (errno == EBADF) {
                        // take it out
                        UVMutexLocker locker(mtx);
                        auto it = fds.find(fd.first);
                        if (it != fds.end())
                            fds.erase(it);
                    } else {
                        // bad
                        fprintf(stderr, "ReadThread read failed %d\n", errno);
                        fflush(stderr);
                        abort();
                    }
                } if (s == 0) {
                    // take it out
                    UVMutexLocker locker(mtx);
                    auto it = fds.find(fd.first);
                    if (it != fds.end())
                        fds.erase(it);
                } else {
                    // null terminate
                    buf[s] = '\0';
                    // libuv doesn't guarantee that one async = one call so we explicitly make sure that is the case
                    UVMutexLocker locker(mtx);

                    // printf("sending async stdout\n");

                    AsyncData data = { buf, fd.second };
                    async.data = &data;
                    uv_async_send(&async);

                    finished = false;
                    while (!finished) {
                        cond.wait(mtx);
                    }
                }
            }
        }
        if (FD_ISSET(wakeup[0], &rd)) {
            // read a char;
            char c;
            eintrwrap(s, ::read(wakeup[0], &c, 1));
            if (s <= 0) {
                fprintf(stderr, "ReadThread read (pipe) failed %d %d\n", s, errno);
                fflush(stderr);
                abort();
            }
            if (c == 'q') {
                // done!
                return;
            }
        }
    };
}

void ReadThread::done(uv_work_t* work, int /*status*/)
{
    uv_close(reinterpret_cast<uv_handle_t*>(&async), 0);
}

// this happens in the main thread
void ReadThread::asyncCall(uv_async_t* handle, int /*status*/)
{
    UVMutexLocker locker(mtx);
    assert(!finished);

    // process the data
    AsyncData* data = static_cast<AsyncData*>(handle->data);

    locker.unlock();
    data->chain->notifyRead(data->str);
    locker.relock();

    finished = true;
    cond.signal();
}

static int chldPipe[2];

static void chldHandler(int sig, siginfo_t */*siginfo*/, void */*context*/)
{
    int w;
    const char s = static_cast<char>(sig);
    eintrwrap(w, ::write(chldPipe[1], &s, 1));
    // printf("got sigchld\n");
}

class WaitThread
{
public:
    WaitThread(uv_loop_t* loop);
    ~WaitThread();

    bool addPid(pid_t pid, ProcessChain* chain, int* status = 0);
    void stop();

private:
    static void run(uv_work_t* work);
    static void done(uv_work_t* work, int status);
    static void asyncCall(uv_async_t* handle, int status);

    void run();

private:
    std::map<pid_t, ProcessChain*> pids;
    std::map<pid_t, int> caught;

    struct AsyncData
    {
        pid_t pid;
        int status;
        ProcessChain* chain;
    };

    static UVMutex mtx;
    static UVCondition cond;
    static bool finished;
    static uv_async_t async;
    static uv_work_t work;
};

UVMutex WaitThread::mtx;
UVCondition WaitThread::cond;
bool WaitThread::finished;
uv_async_t WaitThread::async;
uv_work_t WaitThread::work;

WaitThread::WaitThread(uv_loop_t* loop)
{
    work.data = this;
    uv_queue_work(loop, &work, run, done);
    uv_async_init(loop, &async, asyncCall);
}

WaitThread::~WaitThread()
{
}

void WaitThread::stop()
{
    ::close(chldPipe[0]);
    ::close(chldPipe[1]);
}

bool WaitThread::addPid(pid_t pid, ProcessChain* chain, int* status)
{
    UVMutexLocker locker(mtx);

    auto it = caught.find(pid);
    if (it != caught.end()) {
        if (status)
            *status = it->second;
        caught.erase(it);
        return false;
    }

    pids[pid] = chain;
    if (status)
        *status = 0;
    return true;
}

void WaitThread::run(uv_work_t* work)
{
    WaitThread* thr = 0;
    {
        UVMutexLocker locker(mtx);
        thr = static_cast<WaitThread*>(work->data);
    }
    thr->run();
}

void WaitThread::run()
{
    pid_t pid;
    int status, s;
    fd_set rd;
    for (;;) {
        FD_ZERO(&rd);
        FD_SET(chldPipe[0], &rd);
        eintrwrap(s, ::select(chldPipe[0] + 1, &rd, 0, 0, 0));
        if (s <= 0) {
            if (s < 0 && errno == EBADF) {
                return;
            }
            fprintf(stderr, "WaitThread select failed %d %d\n", s, errno);
            fflush(stderr);
            abort();
        }
        if (FD_ISSET(chldPipe[0], &rd)) {
            // read
            char c;
            eintrwrap(s, ::read(chldPipe[0], &c, 1));
            // printf("got %x (%d) from chldPipe\n", static_cast<int>(c), s);
            if (s == 0) {
                return;
            } else if (s < 0) {
                fprintf(stderr, "WaitThread read failed %d\n", errno);
                fflush(stderr);
                abort();
            }
        }

        for (;;) {
            eintrwrap(pid, waitpid(WAIT_ANY, &status, WUNTRACED|WNOHANG));
            // printf("got %d (%d) from waitpid\n", pid, errno);
            if (pid > 0) {
                bool found = false;
                ProcessChain* chain = 0;
                {
                    UVMutexLocker locker(mtx);
                    auto it = pids.find(pid);
                    if (it != pids.end()) {
                        // got it, make sure we report
                        found = true;
                        chain = it->second;
                        pids.erase(it);
                    } else {
                        // no, make sure we keep it in case someone comes around
                        caught[pid] = status;
                    }
                }
                if (found) {
                    UVMutexLocker locker(mtx);

                    AsyncData data = { pid, status, chain };
                    async.data = &data;
                    uv_async_send(&async);

                    // printf("sending pid async\n");

                    finished = false;
                    while (!finished) {
                        cond.wait(mtx);
                    }
                }
            } else if (pid == 0 || errno == ECHILD) {
                // nothing to do
                break;
            } else {
                // bad
                fprintf(stderr, "WaitThread waitpid failed %d %d\n", pid, errno);
                fflush(stderr);
                abort();
            }
        }
    }
}

void WaitThread::done(uv_work_t* work, int /*status*/)
{
    uv_close(reinterpret_cast<uv_handle_t*>(&async), 0);
}

// this happens in the main thread
void WaitThread::asyncCall(uv_async_t* handle, int /*status*/)
{
    UVMutexLocker locker(mtx);
    assert(!finished);

    // process the data
    AsyncData* data = static_cast<AsyncData*>(handle->data);
    // printf("got wait done in main (%d %d)\n", data->pid, data->status);

    locker.unlock();
    data->chain->notifyChild(data->pid, data->status);
    locker.relock();

    finished = true;
    cond.signal();
}

static std::once_flag processFlag;

static WaitThread* waitThread = 0;
static ReadThread* readThread = 0;

void cleanupThreads()
{
    readThread->stop();
    waitThread->stop();
}

Persistent<FunctionTemplate> ProcessChain::constructor;

void ProcessChain::init(Handle<Object> target)
{
    HandleScope scope;

    std::call_once(processFlag, []() {
            if (pipe(chldPipe)) {
                fprintf(stderr, "chld pipe failed\n");
                fflush(stderr);
                abort();
            }

            struct sigaction act;
            memset (&act, '\0', sizeof(act));

            act.sa_sigaction = &chldHandler;
            act.sa_flags = SA_SIGINFO;

            if (sigaction(SIGCHLD, &act, NULL) < 0) {
                fprintf(stderr, "sigaction failed\n");
                fflush(stderr);
                abort();
            }

            uv_loop_t* loop = uv_default_loop();
            readThread = new ReadThread(loop);
            waitThread = new WaitThread(loop);

            ::atexit(cleanupThreads);
        });

    Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
    Local<String> name = String::NewSymbol("ProcessChain");

    constructor = Persistent<FunctionTemplate>::New(tpl);
    constructor->InstanceTemplate()->SetInternalFieldCount(1);
    constructor->SetClassName(name);

    NODE_SET_PROTOTYPE_METHOD(constructor, "chain", chain);
    NODE_SET_PROTOTYPE_METHOD(constructor, "write", write);
    NODE_SET_PROTOTYPE_METHOD(constructor, "exec", exec);
    NODE_SET_PROTOTYPE_METHOD(constructor, "cont", cont);

    target->Set(name, constructor->GetFunction());
}

ProcessChain::ProcessChain()
    : ObjectWrap(), mLaunched(false), mInteractive(false), mShellPgid(-1), mPgid(-1),
      mShellTermios(0), mType(Foreground), mStatus(Running)
{
    mFinalPipe[0] = mFinalPipe[1] -1;
    mInPipe[0] = mInPipe[1] -1;
    memset(&mTermios, '\0', sizeof(mTermios));
}

static inline void closePipe(int* pipe)
{
    if (*pipe != -1)
        ::close(*pipe);
    if (*(pipe + 1) != -1)
        ::close(*(pipe + 1));
}

ProcessChain::~ProcessChain()
{
    closePipe(mFinalPipe);
    closePipe(mInPipe);
}

Handle<Value> ProcessChain::New(const Arguments& args)
{
    HandleScope scope;

    if (!args.IsConstructCall()) {
        return ThrowException(Exception::TypeError(String::New("Use the new operator to create instances of this object.")));
    }

    if (args.Length() != 2) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain needs a jsh object and a foreground/background argument")));
    }

    if (args[0].IsEmpty() || !args[0]->IsObject()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain needs a jsh object")));
    }

    ProcessChain* obj = new ProcessChain;

    if (args[1].IsEmpty() || !args[1]->IsInt32()) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("ProcessChain needs a foreground/background argument")));
    }
    obj->mType = static_cast<Type>(Handle<Integer>::Cast(args[1])->Value());

    const Handle<String> interactiveKey = String::New("interactive");
    const Handle<String> pgidKey = String::New("pgid");
    const Handle<String> termiosKey = String::New("termios");

    Handle<Object> jsh = Handle<Object>::Cast(args[0]);
    if (!jsh->Has(interactiveKey) || !jsh->Has(pgidKey) || !jsh->Has(termiosKey)) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("ProcessChain takes a jsh object as argument")));
    }

    Handle<Value> prop;

    prop = jsh->Get(interactiveKey);
    if (prop.IsEmpty() || !prop->IsBoolean()) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("jsh.interactive expected to be a boolean")));
    }
    obj->mInteractive = prop->ToBoolean()->Value();

    prop = jsh->Get(pgidKey);
    if (prop.IsEmpty() || !prop->IsInt32()) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("jsh.pgid expected to be an integer")));
    }
    obj->mShellPgid = prop->ToInteger()->Value();

    prop = jsh->Get(termiosKey);
    if (prop.IsEmpty() || !prop->IsObject()) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("jsh.termios expected to be an object")));
    }
    Handle<Object> propobj = Handle<Object>::Cast(prop);
    if (propobj->InternalFieldCount() != 1) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("jsh.termios expected to be an object with internal field")));
    }
    prop = propobj->GetInternalField(0);
    if (prop.IsEmpty() || !prop->IsExternal()) {
        delete obj;
        return ThrowException(Exception::TypeError(String::New("jsh.termios expected to be an external")));
    }

    obj->mShellTermios = static_cast<termios*>(External::Unwrap(prop));

    obj->Wrap(args.This());

    return args.This();
}

bool ProcessChain::launch()
{
    if (mLaunched)
        return true;

    mPgid = 0;

    HandleScope scope;

    if (::pipe(mFinalPipe)) {
        return false;
    }
    if (::pipe(mInPipe)) {
        return false;
    }

    int stdoutPipe[2];
    int stdinFd = mInPipe[0];
    bool fdAdded = false;

    auto entry = mEntries.cbegin();
    const auto end = mEntries.cend();

    mStatus = (entry == end) ? Terminated : Running;

    while (entry != end) {
        const bool last = (entry + 1 == end);
        if (!last) {
            if (::pipe(stdoutPipe) == -1) {
                fprintf(stderr, "Pipe error %d/%s", errno, strerror(errno));
                return false;
            }

        } else {
            stdoutPipe[0] = mFinalPipe[0];
            stdoutPipe[1] = mFinalPipe[1];
        }

        pid_t pid = ::fork();
        switch (pid) {
        case -1:
            // something horrible has happened
            return false;
        case 0: {
            // child

            if (mInteractive) {
                pid = getpid();
                if (mPgid == 0)
                    mPgid = pid;
                setpgid(pid, mPgid);

                if (mType == Foreground)
                    tcsetpgrp(STDIN_FILENO, mPgid);

                signal(SIGINT, SIG_DFL);
                signal(SIGQUIT, SIG_DFL);
                signal(SIGTSTP, SIG_DFL);
                signal(SIGTTIN, SIG_DFL);
                signal(SIGTTOU, SIG_DFL);
            }

            const size_t asz = entry->arguments.size();
            const char* args[asz + 2];
            args[0] = entry->program.c_str();
            args[asz + 1] = 0;
            for (size_t i = 1; i <= asz; ++i) {
                args[i] = entry->arguments[i - 1].c_str();
            }

            const size_t esz = entry->environment.size();
            const char* env[esz + 1];
            env[esz] = 0;
            for (size_t i = 0; i < esz; ++i) {
                env[i] = entry->environment[i].c_str();
            }

            // dups
            ::dup2(stdinFd, STDIN_FILENO);
            if (stdinFd != mInPipe[0]) {
                ::close(mInPipe[0]);
            }
            ::close(mInPipe[1]);
            ::close(stdinFd);

            ::close(stdoutPipe[0]);
            ::dup2(stdoutPipe[1], STDOUT_FILENO);
            ::close(stdoutPipe[1]);

            if (!entry->cwd.empty() && ::chdir(entry->cwd.c_str()) == -1) {
                fprintf(stderr, "chdir error %d/%s", errno, strerror(errno));
                return false;
            }

            if (entry->environment.empty())
                ::execv(entry->program.c_str(), const_cast<char* const*>(args));
            else
                ::execve(entry->program.c_str(), const_cast<char* const*>(args), const_cast<char* const*>(env));
            _exit(1);
            break; }
        default:
            // parent

            if (mInteractive) {
                if (!mPgid)
                    mPgid = pid;
                setpgid(pid, mPgid);
            }

            ::close(stdoutPipe[1]);
            stdinFd = stdoutPipe[0];

            int status;
            if (!waitThread->addPid(pid, this, &status)) {
                mPids.insert(std::make_pair(pid, PidEntry(status)));
            } else {
                fdAdded = true;
                mPids.insert(std::make_pair(pid, PidEntry()));
            }

            break;
        }
        ++entry;
    }

    ::close(mInPipe[0]);
    ::close(mFinalPipe[1]);
    mInPipe[0] = -1;
    mFinalPipe[1] = -1;
    mLaunched = true;

    if (!mPgid)
        return (mStatus == Running);

    readThread->addFd(mFinalPipe[0], this);

    if (mType == Foreground) {
        tcsetpgrp(STDIN_FILENO, mPgid);
    }

    // check if all pids got completed already
    if (!fdAdded && !mPids.empty()) {
        notifyChild(-1, 0);
    }

    return true;
}

Handle<Value> ProcessChain::write(const Arguments& args)
{
    HandleScope scope;

    ProcessChain* obj = ObjectWrap::Unwrap<ProcessChain>(args.This());

    if (args.Length() == 0) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.write requires at least one string argument.")));
    }

    if (!obj->mLaunched && !obj->launch()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.write launch failed.")));
    }

    if (obj->mInPipe[1] == -1) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.write end already called.")));
    }

    for (int i = 0; i < args.Length(); ++i) {
        if (args[i].IsEmpty() || !args[i]->IsString()) {
            return ThrowException(Exception::TypeError(String::New("ProcessChain.write only takes string arguments.")));
        }
        String::Utf8Value val(args[i]);
        int rem = val.length();
        int pos = 0;
        while (rem) {
            const int w = ::write(obj->mInPipe[1], *val + pos, rem);
            if (w <= 0) {
                return ThrowException(Exception::TypeError(String::New("ProcessChain.write ::write failed.")));
            }
            pos += w;
            rem -= w;
        }
    }

    return args.Holder();
}

Handle<Value> ProcessChain::chain(const Arguments& args)
{
    HandleScope scope;

    ProcessChain* obj = ObjectWrap::Unwrap<ProcessChain>(args.This());

    if (args.Length() != 1 || args[0].IsEmpty() || !args[0]->IsObject()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.chain() requires an object argument.")));
    }
    Handle<Object> arg = Handle<Object>::Cast(args[0]);
    Handle<Value> program = arg->Get(String::New("program"));
    Handle<Value> arguments = arg->Get(String::New("arguments"));
    Handle<Value> environment = arg->Get(String::New("environment"));
    Handle<Value> cwd = arg->Get(String::New("cwd"));
    if (program.IsEmpty() || !program->IsString()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.chain() requires a program argument.")));
    }
    if (!arguments.IsEmpty() && !arguments->IsUndefined() && !arguments->IsArray()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.chain() arguments needs to be an array")));
    }
    if (!environment.IsEmpty() && !environment->IsUndefined() && !environment->IsArray()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.chain() environment needs to be an array")));
    }
    if (!cwd.IsEmpty() && !cwd->IsUndefined() && !cwd->IsString()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.chain() cwd needs to be a string")));
    }

    obj->mEntries.push_back(Entry());
    Entry& entry = obj->mEntries.back();

    {
        String::Utf8Value prog(program);
        if (prog.length() > 0)
            entry.program = *prog;
    }
    if (!cwd.IsEmpty() && !cwd->IsUndefined() && !cwd.IsEmpty()) {
        String::Utf8Value dir(cwd);
        if (dir.length() > 0)
            entry.cwd = *dir;
    }
    if (!arguments.IsEmpty() && arguments->IsArray()) {
        Handle<Array> argarray = Handle<Array>::Cast(arguments);
        for (uint32_t i = 0; i < argarray->Length(); ++i) {
            Handle<Value> arg = argarray->Get(i);
            if (arg.IsEmpty() || !arg->IsString()) {
                return ThrowException(Exception::TypeError(String::New("All arguments in ProcessChain.chain() need to be strings.")));
            }
            String::Utf8Value a(arg);
            if (a.length() > 0)
                entry.arguments.push_back(*a);
        }
    }
    if (!environment.IsEmpty() && environment->IsArray()) {
        Handle<Array> envarray = Handle<Array>::Cast(environment);
        for (uint32_t i = 0; i < envarray->Length(); ++i) {
            Handle<Value> arg = envarray->Get(i);
            if (arg.IsEmpty() || !arg->IsString()) {
                return ThrowException(Exception::TypeError(String::New("All environment variables in ProcessChain.chain() need to be strings.")));
            }
            String::Utf8Value a(arg);
            if (a.length() > 0)
                entry.environment.push_back(*a);
        }
    }

    //return scope.Close(Integer::New(value));
    return args.Holder();
}

Handle<Value> ProcessChain::exec(const Arguments& args)
{
    HandleScope scope;
    ProcessChain* obj = ObjectWrap::Unwrap<ProcessChain>(args.This());

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.exec takes a callback argument")));
    }
    if (args[0].IsEmpty() || !args[0]->IsFunction()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.exec takes a callback argument")));
    }
    obj->mCallback = Persistent<Function>::New(Handle<Function>::Cast(args[0]));

    // send all pending data
    if (!obj->mDatas.empty()) {
        // printf("pending list size %u\n", obj->mDatas.size());
        for (const auto& data : obj->mDatas) {
            // printf("notifying js of %d\n", data.type);
            switch (data.type) {
            case DataEntry::Child: {
                Handle<Object> child = Object::New();
                child->Set(String::New("type"), String::New("child"));
                child->Set(String::New("status"), Integer::New(data.status));
                Handle<Value> val = child;
                obj->mCallback->Call(Context::GetCurrent()->Global(), 1, &val);
                break; }
            case DataEntry::Stdout: {
                Handle<Object> out = Object::New();
                out->Set(String::New("type"), String::New("stdout"));
                out->Set(String::New("data"), String::New(data.data.c_str()));
                Handle<Value> val = out;
                obj->mCallback->Call(Context::GetCurrent()->Global(), 1, &val);
                break; }
            }
        }
        obj->mDatas.clear();
    }

    if (obj->mStatus == Terminated)
        return Undefined();

    if (obj->mStatus == Stopped) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.exec can't exec stopped chains")));
    }

    if (!obj->mLaunched && !obj->launch()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.exec launch failed.")));
    }
    if (obj->mInPipe[1] != -1) {
        ::close(obj->mInPipe[1]);
        obj->mInPipe[1] = -1;
    }

    return Undefined();
}

Handle<Value> ProcessChain::cont(const Arguments& args)
{
    HandleScope scope;

    if (args.Length() != 1) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.cond takes a foreground/background argument")));
    }

    ProcessChain* obj = ObjectWrap::Unwrap<ProcessChain>(args.This());

    if (obj->mStatus == Terminated) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain.cont can't continue terminated chains")));
    }

    if (args[0].IsEmpty() || !args[0]->IsInt32()) {
        return ThrowException(Exception::TypeError(String::New("ProcessChain needs a foreground/background argument")));
    }
    obj->mType = static_cast<Type>(Handle<Integer>::Cast(args[0])->Value());
    if (obj->mType == Foreground) {
        // bring process group to the foreground
        tcsetpgrp(STDIN_FILENO, obj->mPgid);
        tcsetattr(STDIN_FILENO, TCSADRAIN, &obj->mTermios);
    }
    if (obj->mStatus == Stopped) {
        // send a SIGCONT to the process group
        ::kill(-obj->mPgid, SIGCONT);
    }
    obj->mStatus = Running;

    return Undefined();
}

void ProcessChain::notifyChild(pid_t pid, int status)
{
    // printf("got notified %d %d\n", pid, status);

    if (pid != -1) {
        auto entry = mPids.find(pid);
        assert(entry != mPids.end());
        entry->second.status = WIFSTOPPED(status) ? Stopped : Terminated;
        entry->second.code = status;
    }

    // if all pids are no longer running, notify JS
    Status s = Terminated;
    for (auto p : mPids) {
        if (p.second.status == Running) {
            s = Running;
            break;
        } else if (p.second.status == Stopped) {
            s = Stopped;
        }
    }

    mStatus = s;
    // printf("overall status is %d\n", mStatus);

    if (s != Running) {
        // first, bring the shell to the foreground if needed
        if (mType == Foreground) {
            tcsetpgrp(STDIN_FILENO, mShellPgid);

            tcgetattr(STDIN_FILENO, &mTermios);
            tcsetattr(STDIN_FILENO, TCSADRAIN, mShellTermios);
        }

        if (mCallback.IsEmpty()) {
            // printf("no callback, appending to pending list\n");
            // append to pending list
            mDatas.push_back({ DataEntry::Child, s, std::string() });
            return;
        }

        // now notify JS
        HandleScope scope;

        // printf("notifying js\n");
        Handle<Object> obj = Object::New();
        obj->Set(String::New("type"), String::New("child"));
        obj->Set(String::New("status"), Integer::New(s));
        Handle<Value> val = obj;
        mCallback->Call(Context::GetCurrent()->Global(), 1, &val);
    }
}

void ProcessChain::notifyRead(const char* str)
{
    if (mCallback.IsEmpty()) {
        mDatas.push_back({ DataEntry::Stdout, Running, std::string(str) });
        return;
    }

    HandleScope scope;

    Handle<Object> obj = Object::New();
    obj->Set(String::New("type"), String::New("stdout"));
    obj->Set(String::New("data"), String::New(str));
    Handle<Value> val = obj;
    mCallback->Call(Context::GetCurrent()->Global(), 1, &val);
}

ProcessChain::PidEntry::PidEntry(int c)
{
    status = WIFSTOPPED(c) ? Stopped : Terminated;
    code = c;
}

void RegisterModule(Handle<Object> target)
{
    ProcessChain::init(target);
}

NODE_MODULE(ProcessChain, RegisterModule);
