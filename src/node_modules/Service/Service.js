var fs = require('fs');
var net = require('net');

function Service(functions, socket)
{
    function rpc(func, args) {
        var argsArray = [];
        for (var i=0; i<args.length; ++i) {
            argsArray.push(args[i]);
        }
        console.log(argsArray);
        var json = JSON.stringify({ method: func, arguments: argsArray });
        var data = new Buffer(json, 'utf8');
        var size = new Buffer(2);
        size.writeUInt16BE(data.length, 0);
        console.log("WRITING SIZE", socket.write(size));
        console.log("WRITING DATA", socket.write(data));
        console.log('REMOTE CALL', func, args);
    }
    for (var i=0; i<functions.length; ++i) {
        var func = functions[i];
        this[func] = function() { rpc(func, arguments); };
    }
}
Service.prototype.addEventListener = function(listener)
{
    this._eventListeners.push(listener);
};

Service.prototype.removeEventListener = function(listener)
{
    var idx = this._eventListeners.indexOf(listener);
    if (idx != -1) {
        this._eventListeners.splice(idx, 1);
        return true;
    }
    return false;
};

function registerService(name, cb)
{
    var Promise = require('promise');
    var stat = Promise.denodeify(fs.stat);
    var readFile = Promise.denodeify(fs.readFile);
    var writeFile = Promise.denodeify(fs.writeFile);

    var serviceDir = process.env.HOME + '/.jsh/services/' + name + '/';
    var socketFile = serviceDir + 'socket';
    var serviceFile = serviceDir + name + '.js';
    var serviceFileTime;
    var manifestFile = serviceFile + '.manifest';
    var socket;
    var functions;

    stat(serviceFile).
        then(function(s) {
            // console.log('GOT STAT for', serviceFile);
            serviceFileTime = s.mtime.getTime();
            return stat(manifestFile);
        }).
        then(function(s) {
            // console.log('GOT STAT manifest', manifestFile);
            if (s.mtime.getTime() <= serviceFileTime) {
                return updateManifest();
            } else {
                return readManifest();
            }
        }, function(err) {
            return updateManifest();
        }).
        catch(function(err) {
            console.log('Finishing 1', err);
            finish(false);
        });

    function updateManifest()
    {
        var vm = require('vm');
        // console.log('got update manifest');
        readFile(serviceFile, { encoding: 'utf8' }).
            then(function(script) {
                script = 'var module={};' + script + '(function(){var f=[];for(var i in module.exports){if(typeof(module.exports[i])===\'function\')f.push(i);} return f;})()';
                // console.log('running script', script);
                functions = vm.runInNewContext(script, undefined, serviceFile); // no async API for this?
                console.log('GOT FUNCTIONS', functions);
                return writeFile(manifestFile, functions.join(' '));
            }).
            then(function(err) {
                console.log('GOT ERR HERE', err);
                if (err)
                    throw err;
                return connectToServer();
            }).
            catch(function(err) {
                // console.log('GOT ERR HERE', err);
                console.log('Finishing 2', err);
                finish(false); // pass error?
            });
    }

    function readManifest()
    {
        // console.log('got read manifest');
        readFile(manifestFile, { encoding: 'utf8' }).
            then(function(contents) {
                functions = contents.split(' ');
                return connectToServer();
            }, function(err) {
                console.log('Finishing 3', err);
                finish(false);
            });
    }

    function connectToServer()
    {
        var connected = false;
        var timeout;
        socket = new net.Socket;
        // var connect = Promise.denodeify(socket.connect);
        socket.on('error', function(err) {
            if (!connected) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = undefined;
                }
                createServer();
            } else { // need to handle errors that happen later
                console.log('Got error', err);
            }
        });
        socket.on('connect', function() {
            connected = true;
            console.log('We\'re connected');
            finish(true);
        });

        socket.on('connect', function() {
            connected = true;
            console.log('We\'re connected');
            finish(true);
        });

        timeout = setTimeout(function() {
            if (!connected) {
                socket.destroy(); // ???
                console.log('Finishing 4 timed out');
                finish(false);
            }
        }, 10000); // ###

        socket.connect(socketFile);
    }

    function createServer()
    {
        var child_process = require('child_process');

        var startService = jsh.path + "startService.js";

        var child = child_process.fork(startService, ['--module-path=' + serviceFile, '--socket-file=' + socketFile]);
        var timeout = setTimeout(function() {
            child.kill();
            finish(false);
        }, 10000);
        child.on('message', function(msg) {
            console.log("GOT MESSAGE BACK", msg);
            if (msg && msg.ready) {
                connectToServer();
                clearTimeout(timeout);
                timeout = undefined;
            }
        });
        // var tries = 100;
        // function maybeConnect() {
        //     if (--tries < 0) {
        //         finish(false);
        //         return;
        //     }
        //     fs.stat(socketFile, function(result) {
        //         console.log("GOT STAT", result, socketFile);
        //         if (result) {
        //             connectToServer();
        //         } else {
        //             setTimeout(maybeConnect, 100);
        //         }
        //     });
        // }
        // maybeConnect();
    }

    function finish(success) {
        console.log('Finish', success);
        if (success) {
            cb(new Service(functions, socket));
        } else {
            cb(undefined);
        }
    }
}

function launchService(modulePath, socketFile)
{
    var jsh = require('jsh');
    var jshNative = new jsh.native.jsh();
    var lockFile = socketFile + '.lock';
    var lockFD;
    try {
        lockFD = fs.openSync(lockFile, 'a');
        jshNative.flockSync(lockFD, [ 'exclusive' ]);
    } catch (err) {
        console.log("foobar", err);
        return false;
    }

    var module = require(modulePath);
    if (!module)
        return false;

    try {
        fs.unlinkSync(socketFile);
    } catch (err) {}
    console.log("Launching here on server side", modulePath, socketFile, module);
    var connections = [];
    function processPacket(packet)
    {
        var call;
        try {
            call = JSON.parse(packet.toString());
        } catch (err) {
            console.log("Couldn't parse json", packet.toString());
            return;
        }
        // console.log(JSON.stringify(exports));
        // console.log(JSON.stringify(module));
        // for (var i in module) {
        //     console.log("GOT SHIT", i);
        // }
        // console.log(balle);
        console.log(JSON.stringify(module));
        if (typeof module[call.method] === 'function') {
            console.log("Calling function server side", call.method, "with args", call.arguments);
            module[call.method].apply(undefined, call.arguments);
        }

        console.log("Got packet", packet.toString());
    }
    function onConnection(sock)
    {
        console.log("Got connection on server side", connections.length);
        connections.push(sock);
        sock.on('data', function(data) {
            if (!sock.pending) {
                sock.pending = data;
            } else {
                sock.pending = Buffer.concat([sock.pending, data]);
            }
            while (sock.pending.length >= 2) {
                var size = sock.pending.readUInt16BE(0);
                if (size && size <= sock.pending.length - 2) {
                    processPacket(sock.pending.slice(2, 2 + size));
                    sock.pending = sock.pending.slice(2 + size);
                } else {
                    break;
                }
            }
            console.log("GOT DATA", data.length);
        });
        sock.on('close', function() {
            var idx = connections.indexOf(sock);
            connections.splice(idx, 1);
            console.log("LOST CONNECTION");
        });
        sock.on('error', function(err) {
            console.log("GOT SOCKET ERROR", err);
        });
    }
    function exit(code)
    {
        fs.closeSync(lockFD);
        try { fs.unlinkSync(lockFile); } catch(err) {}
        try { fs.unlinkSync(socketFile); } catch(err) {}
        process.exit(code);
    }
    // setInterval(function() { console.log("connections", connections.length); }, 3000);
    var server = net.createServer(onConnection);
    var timeout = setTimeout(function() { exit(1); }, 5000);
    server.on('listening', function() {
        clearTimeout(timeout);
        timeout = undefined;
        if (typeof process === 'Object')
            process.send({ready:true});
    });
    server.on('close', function() { exit(0); });
    server.listen(socketFile);

    process.on('SIGINT', function() { exit(0); });
    return true;
}

// registerService('foobar', function(service) {
//     if (service instanceof Service) {
//         if (service.foo) {
//             service.foo('foobar', 'test');
//         }
//     } else {
//         console.log('NO SERVICE HERE', service);
//     }
//     // console.log(service);
// });

exports.registerService = registerService;
exports.launchService = launchService;

// registerService('foobar', function(result) {
//     console.log('GOT RESULT', result);
// });
