var fs = require('fs');
var net = require('net');

function prepareMessage(object)
{
    var json = JSON.stringify(object);
    var data = new Buffer(json, 'utf8');
    var size = new Buffer(2);
    size.writeUInt16BE(data.length, 0);
    return Buffer.concat([size, data]);
}

function socketRead(sock, data, cb)
{
    if (!sock.pending) {
        sock.pending = data;
    } else {
        sock.pending = Buffer.concat([sock.pending, data]);
    }
    while (sock.pending.length >= 2) {
        var size = sock.pending.readUInt16BE(0);
        if (size && size <= sock.pending.length - 2) {
            cb(sock, sock.pending.slice(2, 2 + size));
            sock.pending = sock.pending.slice(2 + size);
        } else {
            break;
        }
    }
}

function Service(name, functions, socket)
{
    this.name = name;
    this.remoteFunctions = functions;
    this._eventListeners = [];
    jsh.log("FOOBAR", name, functions);
    function rpc(func, args) {
        var argsArray = [];
        for (var i=0; i<args.length; ++i) {
            argsArray.push(args[i]);
        }
        jsh.log(argsArray);
        socket.write(prepareMessage({ method: func, arguments: argsArray }));
    }
    var that = this;
    function initFunctions()
    {
        for (var i=0; i<functions.length; ++i) {
            var func = functions[i];
            that[func] = (function(func) { return function() { rpc(func, arguments); }; })(func);
        }
    }
    initFunctions();
    socket.on('close', function() {
        that.callEventListeners({type:"disconnected"});
        registerServiceInternal(name, function(result) {
            jsh.log("GOT RECONNECTED");
            if (result) {
                socket = result.socket;
                if (JSON.stringify(functions) != JSON.stringify(result.functions)) {
                    for (var i=0; i<functions.length; ++i) {
                        delete that[functions[i]];
                    }
                }
                functions = result.functions;
                initFunctions();
                that.callEventListeners({type:"reconnected"});
            }
        });

        jsh.log('GOT CLOSE');
    });

    socket.on('data', function(data) {
        jsh.log("GOT DATA", data.length);
        socketRead(socketRead, data, function(_, payload) {
            var event;
            try {
                event = JSON.parse(payload.toString());
            } catch (err) {
                jsh.log("Couldn't parse json", payload.toString());
                return;
            }
            that.callEventListeners(event);
        });

        jsh.log('GOT CLOSE');
    });

    // socket

}

Service.prototype.addEventListener = function(listener)
{
    this._eventListeners.push(listener);
};

Service.prototype.removeEventListener = function(listener)
{
    var idx = this._eventListeners.indexOf(listener);
    if (idx != -1) {
        this._eventListeners.splice(idx, 1);
        return true;
    }
    return false;
};

Service.prototype.callEventListeners = function(event)
{
    for (var i=0; i<this._eventListeners.length; ++i) {
        this._eventListeners[i].call(this, event);
    }
};

function registerService(name, cb)
{
    registerServiceInternal(name, function(result) {
        if (result) {
            cb(new Service(name, result.functions, result.socket));
        } else {
            cb(undefined);
        }
    });
}

function registerServiceInternal(name, cb)
{
    var Promise = require('promise');
    var stat = Promise.denodeify(fs.stat);
    var readFile = Promise.denodeify(fs.readFile);
    var writeFile = Promise.denodeify(fs.writeFile);

    var serviceDir = process.env.HOME + '/.jsh/services/' + name + '/';
    var socketFile = serviceDir + 'socket';
    var serviceFile = serviceDir + name + '.js';
    var serviceFileTime;
    var manifestFile = serviceFile + '.manifest';
    var socket;
    var functions;

    stat(serviceFile).
        then(function(s) {
            jsh.log('GOT STAT for', serviceFile);
            serviceFileTime = s.mtime.getTime();
            return stat(manifestFile);
        }).
        then(function(s) {
            jsh.log('GOT STAT manifest', manifestFile);
            if (s.mtime.getTime() <= serviceFileTime) {
                return updateManifest();
            } else {
                return readManifest();
            }
        }, function(err) {
            return updateManifest();
        }).
        catch(function(err) {
            jsh.log('Finishing 1', err);
            finish(false);
        });

    function updateManifest()
    {
        var vm = require('vm');
        jsh.log('got update manifest');
        readFile(serviceFile, { encoding: 'utf8' }).
            then(function(script) {
                script = 'var module={};' + script + '(function(){var f=[];for(var i in module.exports){if(typeof(module.exports[i])===\'function\')f.push(i);} return f;})()';
                // jsh.log('running script', script);
                functions = vm.runInNewContext(script, undefined, serviceFile); // no async API for this?
                jsh.log('GOT FUNCTIONS', functions);
                return writeFile(manifestFile, functions.join(' '));
            }).
            then(function(err) {
                jsh.log('GOT ERR HERE', err);
                if (err)
                    throw err;
                return connectToServer();
            }).
            catch(function(err) {
                // jsh.log('GOT ERR HERE', err);
                jsh.log('Finishing 2', err);
                finish(false); // pass error?
            });
    }

    function readManifest()
    {
        jsh.log('got read manifest');
        readFile(manifestFile, { encoding: 'utf8' }).
            then(function(contents) {
                functions = contents.split(' ');
                return connectToServer();
            }, function(err) {
                jsh.log('Finishing 3', err);
                finish(false);
            });
    }

    function connectToServer()
    {
        var connected = false;
        var timeout;
        socket = new net.Socket;
        // var connect = Promise.denodeify(socket.connect);
        socket.on('error', function(err) {
            if (!connected) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = undefined;
                }
                createServer();
            } else { // need to handle errors that happen later
                jsh.log('Got error', err);
            }
        });
        socket.on('connect', function() {
            connected = true;
            jsh.log('We\'re connected');
            finish(true);
        });

        timeout = setTimeout(function() {
            if (!connected) {
                socket.destroy(); // ???
                jsh.log('Finishing 4 timed out');
                finish(false);
            }
        }, 10000); // ###

        socket.connect(socketFile);
    }

    function createServer()
    {
        var child_process = require('child_process');

        var startService = jsh.path + "startService.js";

        var child = child_process.fork(startService, ['--module-path=' + serviceFile, '--socket-file=' + socketFile]);
        var timeout = setTimeout(function() {
            child.kill();
            finish(false);
        }, 10000);
        child.on('message', function(msg) {
            jsh.log("GOT MESSAGE BACK", msg);
            if (msg && (msg.ready || msg.alreadyLaunched)) {
                connectToServer();
                clearTimeout(timeout);
                timeout = undefined;
            }
        });
        // var tries = 100;
        // function maybeConnect() {
        //     if (--tries < 0) {
        //         finish(false);
        //         return;
        //     }
        //     fs.stat(socketFile, function(result) {
        //         jsh.log("GOT STAT", result, socketFile);
        //         if (result) {
        //             connectToServer();
        //         } else {
        //             setTimeout(maybeConnect, 100);
        //         }
        //     });
        // }
        // maybeConnect();
    }

    function finish(success) {
        jsh.log('Finish', success);
        if (success) {
            cb({functions:functions, socket:socket});
        } else {
            cb(undefined);
        }
    }
}

function launchService(modulePath, socketFile)
{
    var jshNative = require('jsh');
    var jsh = new jshNative.jsh();

    var lockFile = socketFile + '.lock';
    var lockFD;
    try {
        lockFD = fs.openSync(lockFile, 'a');
        jsh.flockSync(lockFD, [ 'exclusive', 'nonblocking' ]);
    } catch (err) {
        if (process && process.send) {
            process.send({alreadyLaunched:true});
        }
        return undefined;
    }

    var module = require(modulePath);
    if (!module)
        return undefined;

    try {
        fs.unlinkSync(socketFile);
    } catch (err) {}

    // console.log("Launching here on server side", modulePath, socketFile, module);

    var connections = [];
    function processPacket(socket, packet)
    {
        var call;
        try {
            call = JSON.parse(packet.toString());
        } catch (err) {
            console.log("Couldn't parse json", packet.toString());
            return;
        }
        // jsh.log(JSON.stringify(exports));
        // jsh.log(JSON.stringify(module));
        // for (var i in module) {
        //     jsh.log("GOT SHIT", i);
        // }
        // jsh.log(balle);
        // console.log(JSON.stringify(module));
        if (typeof module[call.method] === 'function') {
            // console.log("Calling function server side", call.method, "with args", call.arguments);

            module[call.method].apply(module, [socket].concat(call.arguments));
        }

        // console.log("Got packet", packet.toString());
    }
    function onConnection(sock)
    {
        // console.log("Got connection on server side", connections.length);
        connections.push(sock);
        sock.on('data', function(data) {
            socketRead(sock, data, processPacket);
        });
        sock.on('close', function() {
            var idx = connections.indexOf(sock);
            connections.splice(idx, 1);
            // console.log("LOST CONNECTION");
        });
        sock.on('error', function(err) {
            // console.log("GOT SOCKET ERROR", err);
        });
    }
    function exit(code)
    {
        fs.closeSync(lockFD);
        try { fs.unlinkSync(lockFile); } catch(err) {}
        try { fs.unlinkSync(socketFile); } catch(err) {}
        process.exit(code);
    }
    // setInterval(function() { console.log("connections", connections.length); }, 3000);
    var server = net.createServer(onConnection);
    var timeout = setTimeout(function() { exit(1); }, 5000);
    server.on('listening', function() {
        clearTimeout(timeout);
        timeout = undefined;
        if (typeof process === 'object' && typeof process.send === 'function') {
            process.send({ready:true});
        }
    });
    server.on('close', function() { exit(0); });
    server.listen(socketFile);

    process.on('SIGINT', function() { exit(0); });
    return {
        get connections() { return connections; },
        sendEvent: function() {
            var event;
            var sock;
            switch (arguments.length) {
            case 1:
                event = arguments[0];
                break;
            case 2:
                event = arguments[1];
                sock = arguments[0];
                break;
            default:
                throw "Invalid sendEvent. Need two args";
                break;
            }

            var ret = 0;

            // console.log("SENDING EVENT", event);
            if (connections.length) {
                var msg = prepareMessage(event);
                for (var i=0; i<connections.length; ++i) {
                    if (!sock || connections[i] === sock) {
                        connections[i].write(msg);
                        ++ret;
                    }
                }
            }
            return ret;
        }
    };
}

exports.registerService = registerService;
exports.launchService = launchService;
